{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Acceso a datos DAM","text":""},{"location":"#descripcion","title":"Descripci\u00f3n","text":"<p>Material del m\u00f3dulo de Acceso a Datos de 2\u00ba de DAM del IES CAMP DE MORVEDRE.</p> Fecha Versi\u00f3n Descripci\u00f3n 19/09/2025 1.0.0 Adaptaci\u00f3n del material. Estructura web con mkdocs."},{"location":"#enlaces-de-interes","title":"Enlaces de inter\u00e9s","text":"<ul> <li>Todo el material est\u00e1 disponible en el repositorio del m\u00f3dulo</li> </ul>"},{"location":"#autoria-y-revision","title":"Autor\u00eda y revisi\u00f3n","text":"<p>Material original de Bego\u00f1a Paterna y Alicia Salvador. Adaptado y revisado por Jos\u00e9 Manuel Abad.</p>"},{"location":"#repositorio-y-contacto","title":"Repositorio y contacto","text":"<p>https://jmabadlopez.github.io jmabadlopez@edu.gva.es</p>"},{"location":"ejercicios/ud01/ejemplo/","title":"Ejemplo","text":"Fecha Versi\u00f3n Descripci\u00f3n 14/09/2021 1.0.0 Versi\u00f3n inicial. 16/09/2021 1.0.1 Correcci\u00f3n de numeraci\u00f3n de ejercicios. 11/09/2025 1.0.5 Adaptaci\u00f3n mkdocs."},{"location":"ejercicios/ud01/ejemplo/#ejercicios-unidad-1-introduccion-a-la-programacion","title":"Ejercicios Unidad 1 - Introducci\u00f3n a la programaci\u00f3n","text":""},{"location":"ejercicios/ud01/ejemplo/#1-programas-y-algoritmos","title":"1. Programas y Algoritmos.","text":"<p>Responde a las siguientes preguntas con palabras tus (no t\u00e9cnicas).</p> <ol> <li>\u00bfQu\u00e9 hace un programa?</li> <li>\u00bfQu\u00e9 son los datos?</li> <li>\u00bfC\u00f3mo se comunica un programa con el usuario?</li> <li>Un programa y un algoritmo es lo mismo?</li> <li>\u00bfQu\u00e9 es un compilador?</li> <li>\u00bfPor qu\u00e9 Java es portable?</li> <li>Di 3 caracter\u00edsticas deseables de un algoritmo.</li> <li>Di verdadero o falso:<ul> <li>Una aplicaci\u00f3n inform\u00e1tica puede estar formada por muchos programas.</li> <li>Un algoritmo puede representarse de varias maneras.</li> <li>Un algoritmo puede programarse en diversos lenguajes de programaci\u00f3n.</li> <li>C es un lenguaje portable.</li> <li>Necesitamos un compilador de C para cada plataforma.</li> </ul> </li> </ol>"},{"location":"ejercicios/ud01/ejemplo/#2-la-informacion","title":"2. La informaci\u00f3n","text":"<p>Responde a las siguientes preguntas con tus palabras (no hace falta que sean t\u00e9cnicas).</p> <ol> <li>\u00bfC\u00f3mo se guarda la informaci\u00f3n en los ordenadores? \u00bfPor qu\u00e9 tiene que estar organizada?</li> <li>\u00bfCu\u00e1l es la diferencia entre una variable y una constante?</li> <li>Di las tres caracter\u00edsticas de una variable.</li> <li>\u00bfQu\u00e9 problemas puede dar la falta de precisi\u00f3n?</li> <li> <p>Di cu\u00e1les de los siguientes identificadores son correctos o incorrectos:</p> <ul> <li><code>letra</code></li> <li><code>Letra</code></li> <li><code>123precio</code></li> <li><code>__variable__</code></li> <li><code>precio123</code></li> <li><code>cantidad_envases</code></li> <li><code>__.__</code></li> <li><code>Canto total</code></li> <li><code>CHAR</code></li> <li><code>char</code></li> </ul> </li> <li> <p>Piensa 2 ejemplos de datos compuestos y con qu\u00e9 tipos simples pueden estar formados.</p> </li> </ol>"},{"location":"ejercicios/ud01/ejemplo/#3-expresiones","title":"3. Expresiones","text":"<ol> <li> <p>Calcula el valor de cada expresi\u00f3n si es v\u00e1lida. Si no es v\u00e1lida, indica el motivo.</p> <ul> <li><code>10 * 3 + 5 * 2</code></li> <li><code>15 % 4</code></li> <li><code>2 + 7 / 3</code></li> <li><code>4 +\" precio \"</code></li> <li><code>(5 + 2) &lt;8</code></li> <li><code>4&gt; = 4</code></li> <li><code>true OR false</code></li> <li><code>5 OR (2 &lt;3)</code></li> <li><code>(6&gt; = 2) OR (3 &lt;= 5)</code></li> <li><code>NOT (NOT (NOT (4 &lt;10)))</code></li> <li><code>4 + false</code></li> <li><code>4 + 2 * 4 / 2</code></li> <li><code>((5 &lt;0) AND (6&gt; = 7)) OR (45% 5 &lt;= 0</code></li> <li><code>((10 - 4)&gt; 0) OR true</code></li> <li><code>((10-4) &lt;0) OR true</code></li> </ul> </li> <li> <p>Dados los siguientes valores de las variables <code>X = 1, Y = 4, Z = 10</code> y la constante<code>PI = 3.14</code>, eval\u00faa las expresiones siguientes. Importante fijarse en el resultado del tipo de retorno.</p> <ul> <li><code>2 * X + 0.5 * Y - 1/5 * Z</code></li> <li><code>((PI * X ^ 2)&gt; Y) OR ((2 * PI * X) &lt;= Z)</code></li> <li><code>\" Hola, mundo! \" == \"Hola,\" + \"mundo!\"</code></li> <li><code>'a' == 'A'</code></li> </ul> </li> <li> <p>A partir de las siguientes constantes <code>gran = falso; redondo = cierto; suave = falso</code> indica cu\u00e1l ser\u00e1 el valor despu\u00e9s de cada una de las siguientes asignaciones:</p> <ul> <li><code>grande y redondo y suave</code></li> <li><code>grande o redondo o suave</code></li> <li><code>grande y redondo o suave</code></li> <li><code>grande o redondo y suave</code></li> <li><code>grande y (redondo o suave)</code></li> <li><code>(grande o redondo) y suave</code></li> </ul> </li> <li> <p>Indica con par\u00e9ntesis el orden en que el ordenador ejecutar\u00eda las diferentes operaciones.</p> <ul> <li><code>x + y + z</code></li> <li><code>x * y + z</code></li> <li><code>x + y * z</code></li> <li><code>x - y * z</code></li> <li><code>x + y / z</code></li> <li><code>x * y / z</code></li> <li><code>x / y / z</code></li> <li><code>x / y * y + x% y</code></li> <li><code>x / y + z + x</code></li> </ul> </li> <li> <p>Siendo a, b, c y d variables num\u00e9ricas, escribe la expresi\u00f3n l\u00f3gica correspondiente a:</p> <ul> <li>Los valores de b y c son ambos superiores al valor de d:</li> <li>a, b y c son id\u00e9nticos</li> <li>a, b y c son id\u00e9nticos pero diferentes de d</li> <li>b est\u00e1 comprendido, estrictamente, entre los valores de a y c</li> <li>b est\u00e1 comprendido, estrictamente, entre los valores de a y c, y el valor de a es menor que el valor de c</li> <li>Hay, al menos, dos valores id\u00e9nticos entre a, b y c</li> </ul> </li> <li> <p>Observa la siguiente secuencia de instrucciones. Responde a las cuestiones:</p> </li> </ol> <pre><code>a=5;\nb=7;\nc=2;\na=a+b+c;\nb=c/2;\na=a/b+a^c;\nESCRIBIR(a);\n</code></pre> <ul> <li>\u00bfQu\u00e9 valor contiene a despu\u00e9s de la cuarta instrucci\u00f3n?</li> <li>\u00bfQu\u00e9 valor contiene b despu\u00e9s de la quinta instrucci\u00f3n?</li> <li>\u00bfQu\u00e9 valor contiene a despu\u00e9s de la sexta instrucci\u00f3n?</li> <li>\u00bfQu\u00e9 valor imprime la \u00faltima instrucci\u00f3n?   </li> </ul>"},{"location":"unidades/ud02/documentacion_final/","title":"Documentaci\u00f3n final","text":""},{"location":"unidades/ud02/documentacion_final/#7-documentacion-el-fichero-leememd","title":"7. Documentaci\u00f3n: El Fichero LEEME.md","text":"<p>En un proyecto de software el c\u00f3digo fuente por s\u00ed solo no cuenta toda la historia y es fundamental crear documentaci\u00f3n adicional. La forma est\u00e1ndar y m\u00e1s extendida de hacerlo es a trav\u00e9s de un fichero <code>LEEME.md</code> (o <code>README.md</code>). Un proyecto sin un <code>LEEME.md</code> se considera incompleto o poco profesional.</p> <p>El fichero <code>LEEME.md</code> es lo primero que ver\u00e1 cualquier persona (incluido nuestro \"yo\" del futuro) que quiera entender nuestro c\u00f3digo. Es buena pr\u00e1ctica explicar qu\u00e9 hace el proyecto, c\u00f3mo se utiliza y por qu\u00e9 se tomaron algunas decisiones, por ejemplo \u00bfpor qu\u00e9 elegimos un registro de 36 bytes?\u201d o \u201c\u00bfpor qu\u00e9 el nombre del fichero es registros.dat?\".</p> <p>Un buen fichero <code>LEEME.md</code> deber\u00eda contener, como m\u00ednimo, las siguientes secciones: * Nombre del proyecto y breve descripci\u00f3n. * Estructura de Datos: En esta secci\u00f3n se explica el dise\u00f1o de los datos. * Instrucciones de Ejecuci\u00f3n: Pasos claros y sencillos para que otra persona pueda ejecutar nuestro programa. * Decisiones de Dise\u00f1o (Opcional pero Recomendado): Un peque\u00f1o apartado para explicar brevemente por qu\u00e9 tomamos ciertas decisiones.</p> <p>La extensi\u00f3n <code>.md</code> significa Markdown que es un lenguaje de marcado ligero que permite dar formato a un texto plano usando caracteres simples. Podemos crearlo con cualquier editor de texto (IntelliJ, VSCode, Bloc de notas...) y guardarlo con la extensi\u00f3n <code>.md</code>. Plataformas como GitHub, GitLab y otros sistemas de documentaci\u00f3n convierten estos ficheros en p\u00e1ginas web.</p>"},{"location":"unidades/ud02/documentacion_final/#sintaxis-basica-de-markdown-para-empezar","title":"Sintaxis b\u00e1sica de Markdown para empezar","text":"<pre><code># T\u00edtulo de Nivel 1\n## T\u00edtulo de Nivel 2\n### T\u00edtulo de Nivel 3\n**Texto en negrita**\n*Texto en cursiva*\n- Elemento de una lista\n1. Elemento de una lista numerad\n</code></pre> <p>Para bloques de c\u00f3digo, rodearlos con tres comillas invertidas (```) y especificar el lenguaje: <pre><code>```kotlin\nfun main() {\n    println(\"Hola, Markdown!\")\n}\n```\n</code></pre></p>"},{"location":"unidades/ud02/documentacion_final/#ejemplo","title":"Ejemplo:","text":"<pre><code># Gestor de mediciones\nEste es un programa de consola desarrollado en Kotlin para gestionar una colecci\u00f3n de registros de mediciones de temperatura y humedad registradas por unos sensores.\nLos datos se almacenan en un fichero binario de acceso aleatorio llamado *mediciones.dat*\n\n## 1. Estructura de datos\n### **Data Class:**\n``` kotlin\ndata class Sensor(\n    val id_sensor: Int,\n    val nombre: String,\n    val temperatura: Double\n    val humedad: Double\n)\n</code></pre>"},{"location":"unidades/ud02/documentacion_final/#estructura-del-registro-binario","title":"Estructura del registro binario:","text":"<ul> <li>ID: Int - 4 bytes</li> <li>Nombre: String - 20 bytes (longitud fija)</li> <li>temperatura: Double - 8 bytes</li> <li>humedad: Double - 8 bytes</li> <li>Tama\u00f1o Total del Registro: 4 + 20 + 8 + 8 = 40 bytes</li> </ul>"},{"location":"unidades/ud02/documentacion_final/#2-instrucciones-de-ejecucion","title":"2. Instrucciones de ejecuci\u00f3n","text":"<ul> <li>Requisitos previos: Aseg\u00farate de tener un JDK (ej. versi\u00f3n 17 o superior) instalado.</li> <li>Compilaci\u00f3n: Abre el proyecto en IntelliJ IDEA y deja que Gradle sincronice las dependencias.</li> <li>Ejecuci\u00f3n: Ejecuta la funci\u00f3n main del fichero Main.kt.</li> <li>Ficheros necesarios: El programa espera encontrar un fichero datos_iniciales.csv en la carpeta datos_ini dentro de la ra\u00edz del proyecto para la carga inicial de datos.</li> </ul>"},{"location":"unidades/ud02/documentacion_final/#3-decisiones-de-diseno","title":"3. Decisiones de dise\u00f1o","text":"<ul> <li>Eleg\u00ed CSV para los datos iniciales porque es un formato muy f\u00e1cil de crear y editar manualmente con cualquier hoja de c\u00e1lculo.</li> <li>Decid\u00ed que el campo nombre tuviera 20 bytes porque considero que es suficiente para la mayor\u00eda de nombres de sensores sin desperdiciar demasiado espacio.</li> </ul>"},{"location":"unidades/ud02/ficheros_acceso_aleatorio/","title":"Ficheros de acceso aleatorio","text":""},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#6-ficheros-de-acceso-aleatorio","title":"6. Ficheros de acceso aleatorio","text":"<p>Un fichero de acceso aleatorio es un tipo de fichero que permite leer o escribir en cualquier posici\u00f3n del fichero directamente, sin necesidad de procesar secuencialmente todo el contenido previo. El sistema puede \u201csaltar\u201d a una posici\u00f3n concreta (medida en bytes desde el inicio del fichero) y comenzar la lectura o escritura desde ah\u00ed. Por ejemplo, si cada registro ocupa 200 bytes, para acceder al registro n\u00famero 100 hay que saltar 200\u00d799=19.800 bytes desde el inicio.</p> <p>Las clases FileChannel, ByteBuffer y StandardOpenOption se utilizan juntas para leer y escribir en ficheros binarios y en el acceso aleatorio a ficheros. <code>ByteBuffer</code> se utiliza en ficheros de acceso aleatorio porque permite leer y escribir bloques binarios de datos en posiciones espec\u00edficas del fichero.</p>"},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#metodos-de-filechannel","title":"M\u00e9todos de FileChannel","text":"M\u00e9todo Descripci\u00f3n <code>position()</code> Devuelve la posici\u00f3n actual del puntero en el fichero y permite saltar a cualquier posici\u00f3n en \u00e9l (tanto para leer como para escribir). <code>position(long)</code> Establece una posici\u00f3n exacta para lectura/escritura. <code>truncate(long)</code> Recorta o ampl\u00eda el tama\u00f1o del fichero. <code>size()</code> Devuelve el tama\u00f1o total actual del fichero. <code>read(ByteBuffer)</code>, <code>write(ByteBuffer)</code> Usa <code>FileChannel</code> para secuencial o aleatorio."},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#metodos-de-bytebuffer","title":"M\u00e9todos de ByteBuffer","text":"M\u00e9todo Descripci\u00f3n <code>allocate(capacidad)</code> Crea un buffer con capacidad fija en memoria (no compartida). <code>wrap(byteArray)</code> Crea un buffer que envuelve un array de bytes existente (memoria compartida). <code>wrap(byteArray, offset, length)</code> Crea un buffer desde una porci\u00f3n del array existente. <code>put(byte)</code>, <code>putInt(int)</code>, <code>putDouble(double)</code>, <code>putFloat(float)</code>, <code>putChar(char)</code>, <code>putShort(short)</code>, <code>putLong(long)</code> Escribe un byte, int, double, float, char, short o long en la posici\u00f3n actual. <code>put(byte[], offset, length)</code> Escribe una porci\u00f3n de un array de bytes. <code>get()</code>, <code>getInt()</code>, <code>getDouble()</code>, <code>getFloat()</code>, <code>getChar()</code>, <code>getShort()</code>, <code>getLong()</code> Lee un byte, int, double, float, char, short o long desde la posici\u00f3n actual. <code>get(byte[], offset, length)</code> Lee una porci\u00f3n del buffer a un array."},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#metodos-de-control-del-buffer","title":"M\u00e9todos de control del buffer","text":"M\u00e9todo Descripci\u00f3n <code>position()</code> Devuelve la posici\u00f3n actual del cursor. <code>position(int)</code> Establece la posici\u00f3n del cursor. <code>limit()</code> Devuelve el l\u00edmite del buffer. <code>limit(int)</code> Establece un nuevo l\u00edmite. <code>capacity()</code> Devuelve la capacidad total del buffer. <code>clear()</code> Limpia el buffer: posici\u00f3n a 0, l\u00edmite al m\u00e1ximo (sin borrar contenido). <code>flip()</code> Prepara el buffer para lectura despu\u00e9s de escribir. <code>rewind()</code> Posici\u00f3n a 0 para releer desde el inicio. <code>remaining</code> Indica cu\u00e1ntos elementos quedan por procesar. <code>hasRemaining()</code> <code>true</code> si a\u00fan queda contenido por leer o escribir. <p>IMPORTANTE: un fichero <code>.dat</code> no es un fichero de texto. No se puede abrir con el Bloc de Notas, TextEdit, o un editor de c\u00f3digo en modo texto normal. Si se abre con estos programas se ve una mezcla de caracteres extra\u00f1os, s\u00edmbolos y espacios (\"basura\"). Hay herramientas online y plugins para los IDE para poder abrir los ficheros y ver la informaci\u00f3n en binario que contienen.</p>"},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#ejemplo","title":"Ejemplo:","text":"<p>El siguiente ejemplo utiliza <code>FileChannel</code> y <code>ByteBuffer</code> para crear y leer un fichero llamado <code>mediciones.dat</code> con registros con la siguiente estructura:</p> <ul> <li>ID del sensor (<code>Int</code> - 4 bytes)</li> <li>temperatura (<code>Double</code> - 8 bytes)</li> <li>humedad (<code>Double</code> - 8 bytes)</li> </ul> <p>A continuaci\u00f3n se muestra el c\u00f3digo con las funciones para a\u00f1adir una medici\u00f3n al final del fichero y leer todas las mediciones que hay en \u00e9l. <pre><code>import java.nio.ByteBuffer // \"contenedor\" de bytes en memoria.\nimport java.nio.ByteOrder // especificar el orden de los bytes\nimport java.nio.channels.FileChannel //canal que conecta con el fichero\nimport java.nio.file.Files\nimport java.nio.file.Path\nimport java.nio.file.StandardOpenOption\nconst val TAMANO_ID = Int.SIZE_BYTES // 4 bytes\nconst val TAMANO_NOMBRE = 20 // String de tama\u00f1o fijo 20 bytes\nconst val TAMANO_TEMPERATURA = Double.SIZE_BYTES // 8 bytes\nconst val TAMANO_HUMEDAD = Double.SIZE_BYTES // 8 bytes\nconst val TAMANO_REGISTRO = TAMANO_ID + TAMANO_NOMBRE + TAMANO_TEMPERATURA + TAMANO_HUMEDAD\nfun main() {\n    val rutaFichero = Path.of(\"mediciones.dat\")\n    escribirMedicion(rutaFichero, 101, \"Atenea\",25.5, 60.2)\n    escribirMedicion(rutaFichero, 102, \"Hera\",26.1, 58.9)\n    escribirMedicion(rutaFichero, 103, \"Iris\",28.4, 65.9)\n    escribirMedicion(rutaFichero, 104, \"Selene\",28.4, 65.9)\n    leerMediciones(rutaFichero) //leer todas las mediciones\n}\n// Funci\u00f3n que escribe una medici\u00f3n en el fichero.\nfun escribirMedicion(ruta: Path, idSensor: Int, nombre: String, temperatura: Double, humedad: Double) {\n    /* .use { ... } abre el canal (se cerrar\u00e1 autom\u00e1ticamente al final del bloque) Escribir con APPEND para a\u00f1adir el final */\n    FileChannel.open(ruta, StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.APPEND).use { canal -&gt;\n        // Crear un ByteBuffer de nuestro tama\u00f1o y especificamos el orden de bytes\n        val buffer = ByteBuffer.allocate(TAMANO_REGISTRO)\n        buffer.order(ByteOrder.nativeOrder())\n        /* Escribimos los datos en el buffer en el orden correcto.\n        'put' avanza la \"posici\u00f3n\" interna del buffer.*/\n        buffer.putInt(idSensor) // Escribe 4 bytes\n        /* Para escribir el String hay que convertirlo a un array de bytes de tama\u00f1o fijo.\n        Inicializamos el array de bytes rellen\u00e1ndolo con el car\u00e1cter espacio.\n        ' '.code.toByte() convierte el car\u00e1cter espacio a su valor de byte.*/\n        val nombreCompleto = ByteArray(TAMANO_NOMBRE) { ' '.code.toByte() }\n        // Convertimos el String de entrada a un array de bytes temporal.\n        val nombreBytes = nombre.toByteArray(Charsets.UTF_8)\n        /* Copiamos los bytes del String al principio de nuestro array de tama\u00f1o fijo.\n        Si 'nombre' ocupa menos de 20 bytes, el resto de 'nombreCompleto' seguir\u00e1 relleno de espacios.\n        Si 'nombre' ocupa m\u00e1s de 20 bytes, solo se copiar\u00e1n los primeros 20.*/\n        nombreBytes.copyInto(nombreCompleto)\n        buffer.put(nombreCompleto) // Escribe 20 bytes\n        buffer.putDouble(temperatura) // Escribe 8 bytes\n        buffer.putDouble(humedad) // Escribe 8 bytes\n        /* 'flip()' prepara el buffer para ser le\u00eddo o escrito\n        Resetea la 'posici\u00f3n' a 0 y limita al tama\u00f1o total\n        El canal escribir\u00e1 desde la posici\u00f3n 0 hasta la 20 */\n        buffer.flip()\n        // Escribimos el contenido del buffer en el fichero a trav\u00e9s del canal.\n        canal.write(buffer)\n        println (\"Medici\u00f3n (ID: $idSensor) escrita correctamente.\")\n    }\n}\n// Funci\u00f3n que lee TODAS las mediciones almacenadas en el fichero.\nfun leerMediciones(ruta: Path) {\n    if (!Files.exists(ruta)) {\n        println (\"El fichero ${ruta.fileName} no existe. No hay nada que leer.\")\n    } else {\n        println (\"\\n--- Leyendo todas las mediciones ---\")\n        FileChannel.open(ruta, StandardOpenOption.READ).use { canal -&gt;\n            // Crear buffer\n            val buffer = ByteBuffer.allocate(TAMANO_REGISTRO)\n            buffer.order(ByteOrder.nativeOrder())\n            /* Leer del canal en un bucle hasta que se alcance el final del fichero.\n            canal.read(buffer) lee bytes del fichero y los guarda en el buffer.\n            Devuelve el n\u00famero de bytes le\u00eddos, o -1 si ya no hay m\u00e1s datos. */\n            while (canal.read(buffer) &gt; 0) {\n                /* Despu\u00e9s de `canal.read()` su posici\u00f3n est\u00e1 al final.\n                `flip()` resetear la posici\u00f3n a 0. Para poder leer\n                los datos que acabamos de cargar desde el principio del buffer. */\n                buffer.flip()\n                // Leemos los datos en el mismo orden en que los escribimos.\n                val id = buffer.getInt()\n                // Crear un array de bytes vac\u00edo para guardar los datos del nombre.\n                val nombreCompleto = ByteArray(TAMANO_NOMBRE)\n                // Leer 20 bytes del buffer y los guardamos en nuestro array.\n                buffer.get(nombreCompleto)\n                /* Convertir el array de bytes a un String. Usar .trim() para eliminar\n                los espacios en blanco que se escribieron al final */\n                val nombre = String(nombreCompleto, Charsets.UTF_8).trim()\n                val temp = buffer.getDouble()\n                val hum = buffer.getDouble()\n                println (\"  - ID: $id, Nombre: $nombre, Temperatura: $temp \u00b0C, Humedad: $hum %\")\n                // `clear()` resetea la posici\u00f3n a 0 y el l\u00edmite a la capacidad total.\n                buffer.clear()\n            }\n        }\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Medici\u00f3n (ID: 101) escrita correctamente.\nMedici\u00f3n (ID: 102) escrita correctamente.\nMedici\u00f3n (ID: 103) escrita correctamente.\nMedici\u00f3n (ID: 104) escrita correctamente.\n\n--- Leyendo todas las mediciones ---\n  - ID: 101, Nombre: Atenea, Temperatura: 25.5 \u00b0C, Humedad: 60.2 %\n  - ID: 102, Nombre: Hera, Temperatura: 26.1 \u00b0C, Humedad: 58.9 %\n  - ID: 103, Nombre: Iris, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n  - ID: 104, Nombre: Selene, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n</code></pre></p> <p>Ahora que ya tenemos la informaci\u00f3n guardada en nuestro fichero <code>.dat</code> y sabemos leerla, vamos a ampliar la aplicaci\u00f3n con una funci\u00f3n que recoge el ID del sensor a modificar y los nuevos datos de temperatura y humedad. Cuando localiza el registro del sensor cuyo ID coincide con el buscado, escribe los nuevos datos en las posiciones de los bytes correspondientes.</p> <pre><code>fun actualizarMedicion(ruta: Path, idSensorBuscado: Int, nuevaTemperatura: Double, nuevaHumedad: Double) {\n    if (!Files.exists(ruta)) {\n        println (\"Error: El fichero no existe, no se puede actualizar.\")\n    } else {\n        println (\"\\nIntentando actualizar medici\u00f3n para ID: $idSensorBuscado...\")\n        FileChannel.open(ruta, StandardOpenOption.READ, StandardOpenOption.WRITE).use { canal -&gt;\n            // Creamos un buffer peque\u00f1o, solo para leer el ID en cada iteraci\u00f3n.\n            // No necesitamos cargar el registro completo solo para buscar.\n            val buffer = ByteBuffer.allocate(TAMANO_ID)\n            buffer.order(ByteOrder.nativeOrder())\n            var posicionActual: Long = 0\n            var encontrado = false\n            while (canal.position() &lt; canal.size() &amp;&amp; !encontrado) {\n                // Guardar la posici\u00f3n del inicio del registro que estamos a punto de leer.\n                posicionActual = canal.position()\n\n                // Limpiamos y leemos solo los 4 bytes del ID.\n                buffer.clear()\n                canal.read(buffer)\n\n                // Preparamos el buffer para leer el entero.\n                buffer.flip()\n                val idActual = buffer.getInt()\n                println (\"leyendo ID: \" + idActual)\n                // Comparamos el ID le\u00eddo con el que estamos buscando.\n                if (idActual == idSensorBuscado) {\n                    encontrado = true\n                    println (\"Sensor $idSensorBuscado en posici\u00f3n $posicionActual.\")\n                    // Posici\u00f3n temperatura = inicio registro + tama\u00f1o del ID + tama\u00f1o nombre\n                    canal.position(posicionActual + TAMANO_ID + TAMANO_NOMBRE)\n                    val bufferDatos = ByteBuffer.allocate(TAMANO_TEMPERATURA + TAMANO_HUMEDAD)\n                    bufferDatos.order(ByteOrder.nativeOrder())\n                    bufferDatos.putDouble(nuevaTemperatura)\n                    bufferDatos.putDouble(nuevaHumedad)\n                    bufferDatos.flip()\n                    canal.write(bufferDatos)\n                    println (\"Medici\u00f3n actualizada con \u00e9xito a Temp: $nuevaTemperatura, Hum: $nuevaHumedad.\")\n                } else {\n                    canal.position(posicionActual + TAMANO_REGISTRO)\n                }\n            }\n            if (!encontrado) {\n                println (\"Medici\u00f3n con ID: $idSensorBuscado no encontrada\")\n            }\n        }\n    }\n}\n</code></pre> <p>La llamada a esta nueva funci\u00f3n en el main podr\u00eda ser: <pre><code>actualizarMedicion(rutaFichero, 102, 21.0, 72.3)\n</code></pre></p> <p>Se vuelve a llamar a <code>leerMediciones</code> para comprobar que la informaci\u00f3n del sensor se ha modificado correctamente: <pre><code>leerMediciones(rutaFichero)\n</code></pre></p> <p>\ud83d\udd0d Realiza los siguientes pasos:</p> <ul> <li>A\u00f1ade el c\u00f3digo de la funci\u00f3n <code>actualizarMedicion()</code> al proyecto del ejemplo anterior.</li> <li>Comenta en el <code>main</code> las llamadas a la funci\u00f3n <code>escribirMedicion()</code>.</li> <li>A\u00f1ade al <code>main</code> las llamadas a <code>actualizarMedicion()</code> y a <code>leerMediciones()</code>.</li> <li>Ejecuta la aplicaci\u00f3n y comprueba que la salida es la siguiente: <pre><code>--- Leyendo todas las mediciones ---\n  - ID: 101, Nombre: Atenea, Temperatura: 25.5 \u00b0C, Humedad: 60.2 %\n  - ID: 102, Nombre: Hera, Temperatura: 26.1 \u00b0C, Humedad: 58.9 %\n  - ID: 103, Nombre: Iris, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n  - ID: 104, Nombre: Selene, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n\nIntentando actualizar medici\u00f3n para ID: 102...\nleyendo ID: 101\nleyendo ID: 102\nSensor 102 en posici\u00f3n 40.\nMedici\u00f3n actualizada con \u00e9xito a Temp: 21.0, Hum: 72.3.\n\n--- Leyendo todas las mediciones ---\n  - ID: 101, Nombre: Atenea, Temperatura: 25.5 \u00b0C, Humedad: 60.2 %\n  - ID: 102, Nombre: Hera, Temperatura: 21.0 \u00b0C, Humedad: 72.3 %\n  - ID: 103, Nombre: Iris, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n  - ID: 104, Nombre: Selene, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n</code></pre></li> </ul> <p>Por \u00faltimo, ampliaremos la aplicaci\u00f3n para poder eliminar los datos de un sensor a partir de su ID. El programa recorre todo los registros comprobando si el ID coincide con el buscado. En caso de que no coincida escribe el registro en un fichero temporal y si coincide, no hace nada. Al finalizar el fichero temporal contendr\u00e1 los registros que no se quieren eliminar. Por \u00faltimo, se elimina el fichero original y se renombra el fichero temporal con el nombre original.</p> <pre><code>fun eliminarMedicion(ruta: Path, idSensorAEliminar: Int) {\n    val rutaTemp = Path.of(\"temp.dat\")\n    if (!Files.exists(ruta)) {\n        println (\"Error: El fichero no existe, no se puede actualizar.\")\n    } else {\n        println (\"\\nIntentando eliminar medici\u00f3n para el sensor con ID: $idSensorAEliminar...\")\n        FileChannel.open(ruta, StandardOpenOption.READ).use { canal -&gt;\n            // Crear buffer\n            val buffer = ByteBuffer.allocate(TAMANO_REGISTRO)\n            buffer.order(ByteOrder.nativeOrder())\n            /* Leer del canal en un bucle hasta que se alcance el final del fichero.\n            canal.read(buffer) lee bytes del fichero y los guarda en el buffer.\n            Devuelve el n\u00famero de bytes le\u00eddos, o -1 si ya no hay m\u00e1s datos. */\n            while (canal.read(buffer) &gt; 0) {\n                /* Despu\u00e9s de `canal.read()` su posici\u00f3n est\u00e1 al final.\n                `flip()` resetear la posici\u00f3n a 0. Para poder leer\n                los datos que acabamos de cargar desde el principio del buffer. */\n                buffer.flip()\n                // Leemos los datos en el mismo orden en que los escribimos.\n                val id = buffer.getInt()\n                // Crear un array de bytes vac\u00edo para guardar los datos del nombre.\n                val nombreCompleto = ByteArray(TAMANO_NOMBRE)\n                // Leer 20 bytes del buffer y los guardamos en nuestro array.\n                buffer.get(nombreCompleto)\n                /* Convertir el array de bytes a un String. Usar .trim() para eliminar\n                los espacios en blanco que se escribieron al final */\n                val nombre = String(nombreCompleto, Charsets.UTF_8).trim()\n                val temp = buffer.getDouble()\n                val hum = buffer.getDouble()\n                if (id!=idSensorAEliminar) {\n                    // Usar nuestra funci\u00f3n par escribir en el fichero temporal\n                    escribirMedicion(rutaTemp, id, nombre, temp, hum)\n                }\n                buffer.clear()\n            }\n        }\n        Files.delete(ruta) //borrar fichero original\n        Files.move(rutaTemp, ruta) // renombrar temporal\n    }\n}\n</code></pre> <p>La llamada a esta nueva funci\u00f3n en el main podr\u00eda ser: <pre><code>eliminarMedicion(rutaFichero, 102)\n</code></pre> Se vuelve a llamar a <code>leerMediciones</code> para comprobar que la informaci\u00f3n del sensor se ha modificado correctamente: <pre><code>leerMediciones(rutaFichero)\n</code></pre></p> <p>\ud83d\udd0d Realiza los siguientes pasos:</p> <ul> <li>A\u00f1ade el c\u00f3digo de la funci\u00f3n <code>eliminarMedicion()</code> al ejemplo anterior.</li> <li>Comenta en el <code>main</code> la llamada a la funci\u00f3n <code>actualizarMedicion()</code>.</li> <li>A\u00f1ade al <code>main</code> la llamada a <code>eliminarMedicion()</code>.</li> <li>Ejecuta la aplicaci\u00f3n y comprueba que la salida es la siguiente: <pre><code>--- Leyendo todas las mediciones ---\n  - ID: 101, Nombre: Atenea, Temperatura: 25.5 \u00b0C, Humedad: 60.2 %\n  - ID: 102, Nombre: Hera, Temperatura: 21.0 \u00b0C, Humedad: 72.3 %\n  - ID: 103, Nombre: Iris, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n  - ID: 104, Nombre: Selene, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n\nIntentando eliminar medici\u00f3n para el sensor con ID: 102...\nMedici\u00f3n (ID: 101) escrita correctamente.\nMedici\u00f3n (ID: 103) escrita correctamente.\nMedici\u00f3n (ID: 104) escrita correctamente.\n\n--- Leyendo todas las mediciones ---\n  - ID: 101, Nombre: Atenea, Temperatura: 25.5 \u00b0C, Humedad: 60.2 %\n  - ID: 103, Nombre: Iris, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n  - ID: 104, Nombre: Selene, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n</code></pre></li> </ul>"},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#practica-5-modificar-y-eliminar-registros-en-ficheros-dat","title":"\ud83c\udfaf Pr\u00e1ctica 5: Modificar y eliminar registros en ficheros .dat","text":"<p>Realiza lo siguiente: * Crea la funci\u00f3n <code>modificarReg()</code>: Pedir\u00e1 al usuario el ID del registro a modificar y buscar\u00e1 ese registro en el fichero. Si lo encuentra, pedir\u00e1 los nuevos datos. Utilizar\u00e1 acceso aleatorio (<code>FileChannel.position()</code>) para saltar a la posici\u00f3n exacta de ese registro y sobrescribir \u00fanicamente los campos modificados, sin alterar el resto del fichero. * Crea la funci\u00f3n <code>eliminarReg()</code>: Debe recibir un ID y eliminar el registro correspondiente. Implementa la t\u00e9cnica de streaming (leer el fichero original registro a registro, escribir los que se conservan en un fichero temporal, borrar el original y renombrar el temporal). * Comprueba: Prueba estas funciones desde <code>main</code>, llamando a <code>mostrarTodo()</code> antes y despu\u00e9s de cada operaci\u00f3n para verificar los resultados.</p>"},{"location":"unidades/ud02/ficheros_binarios/","title":"Ficheros binarios","text":""},{"location":"unidades/ud02/ficheros_binarios/#5-ficheros-binarios","title":"5. Ficheros binarios","text":"<p>Los ficheros binarios no son legibles directamente por humanos (.exe, .jpg, .mp3, .dat). En ellos los datos pueden estar no estructurados o estructurados.</p>"},{"location":"unidades/ud02/ficheros_binarios/#51-ficheros-binarios-no-estructurados","title":"5.1. Ficheros binarios no estructurados","text":"<p>En los ficheros binarios no estructurados los datos se escriben \u201ctal cual\u201d en bytes, sin un formato estructurado definido por un est\u00e1ndar. El programa que los lee necesita saber c\u00f3mo interpretar esos bytes.</p>"},{"location":"unidades/ud02/ficheros_binarios/#metodos-de-ficheros-binarios-no-estructurados","title":"M\u00e9todos de Ficheros Binarios No Estructurados","text":"M\u00e9todo Descripci\u00f3n <code>Files.readAllBytes(Path)</code>, <code>Files.write(Path, ByteArray)</code> Lee y escribe bytes puros. <code>Files.newInputStream(Path)</code>, <code>Files.newOutputStream(Path)</code> Flujo de bytes directo."},{"location":"unidades/ud02/ficheros_binarios/#ejemplo-binario-no-estructurado","title":"Ejemplo binario no estructurado:","text":"<p>Escribir bit a bit los datos <code>1 2 3 4 5</code> en un fichero llamado <code>datos.bin</code>. <pre><code>import java.io.IOException\nimport java.nio.file.Files\nimport java.nio.file.Path\nfun main() {\n    val ruta = Path.of(\"multimedia/bin/datos.bin\")\n    try {\n        // Asegura que el directorio 'documentos' existe\n        val directorio = ruta.parent\n        if (directorio != null &amp;&amp; !Files.exists(directorio)) {\n            Files.createDirectories(directorio)\n            println (\"Directorio creado: ${directorio.toAbsolutePath()}\")\n        }\n        // Verifica si se puede escribir\n        if (!Files.isWritable(directorio)) {\n            println (\"No se tienen permisos de escritura en el directorio: $directorio\")\n        } else {\n            // Datos a escribir\n            val datos = byteArrayOf(1, 2, 3, 4, 5)\n            Files.write(ruta, datos)\n            println (\"Fichero binario creado: ${ruta.toAbsolutePath()}\")\n            // Verifica si se puede leer\n            if (!Files.isReadable(ruta)) {\n                println (\"No se tienen permisos de lectura para el fichero: $ruta\")\n            } else {\n                // Lectura del fichero binario\n                val bytes = Files.readAllBytes(ruta)\n                println (\"Contenido le\u00eddo (byte a byte):\")\n                for (b in bytes) {\n                    print (\"$b \")\n                }\n            }\n        }\n    } catch (e: IOException) {\n        println (\"Ocurri\u00f3 un error de entrada/salida: ${e.message}\")\n    } catch (e: SecurityException) {\n        println (\"No se tienen permisos suficientes: ${e.message}\")\n    } catch (e: Exception) {\n        println (\"Error inesperado: ${e.message}\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Directorio creado: F:\\kot\\1-ficheros\\ejemplos1\\multimedia\\bin\nFichero binario creado: F:\\kot\\1-ficheros\\ejemplos1\\multimedia\\bin\\datos.bin\nContenido le\u00eddo (byte a byte):\n1 2 3 4 5\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_binarios/#52-ficheros-binarios-estructurados","title":"5.2. Ficheros binarios estructurados","text":"<p>En los ficheros binarios estructurados los datos se guardan de forma estructurada siguiendo una organizaci\u00f3n predefinida, con campos y tipos de datos, a veces con un formato est\u00e1ndar (ej. PNG, ZIP, MP3, etc.) que pueden incluir cabeceras (con informaci\u00f3n como versi\u00f3n, tama\u00f1o, etc.) y registros (con campos fijos o delimitadores). El orden de bytes y los tama\u00f1os est\u00e1n definidos, lo que permite a cualquier programa que conozca el formato leerlo correctamente. Las clases <code>DataOutputStream</code> y <code>DataInputStream</code> de java.io sirven para leer y escribir ficheros binarios estructurados.</p>"},{"location":"unidades/ud02/ficheros_binarios/#metodos-de-dataoutputstream","title":"M\u00e9todos de DataOutputStream","text":"M\u00e9todo Descripci\u00f3n <code>writeInt(int)</code> Escribe un entero con signo. Entero (4 bytes). <code>writeDouble(double)</code> Escribe un n\u00famero en coma flotante. Decimal (8 bytes). <code>writeFloat(float)</code> Escribe un n\u00famero float. Decimal (4 bytes). <code>writeLong(long)</code> Escribe un long. Entero largo (8 bytes). <code>writeBoolean(boolean)</code> Escribe un valor verdadero/falso. Booleano (1 byte). <code>writeChar(char)</code> Escribe un car\u00e1cter Unicode. Car\u00e1cter (2 bytes). <code>writeUTF(String)</code> Escribe una cadena precedida por su longitud en 2 bytes. Cadena UTF-8. <code>writeByte(int)</code> Escribe un solo byte. Byte (1 byte). <code>writeShort(int)</code> Escribe un short. Entero corto (2 bytes)."},{"location":"unidades/ud02/ficheros_binarios/#metodos-de-datainputstream","title":"M\u00e9todos de DataInputStream","text":"M\u00e9todo Descripci\u00f3n <code>readInt()</code> Lee un entero con signo (Entero). <code>readDouble()</code> Lee un n\u00famero double (Decimal). <code>readFloat()</code> Lee un n\u00famero float (Decimal). <code>readLong()</code> Lee un long (Entero largo). <code>readBoolean()</code> Lee un valor verdadero/falso (Booleano). <code>readChar()</code> Lee un car\u00e1cter Unicode (Car\u00e1cter). <code>readUTF()</code> Lee una cadena UTF-8 (Cadena UTF-8). <code>readByte()</code> Lee un byte (Byte). <code>readShort()</code> Lee un short (Entero corto)."},{"location":"unidades/ud02/ficheros_binarios/#ejemplo","title":"Ejemplo:","text":"<p>Lectura y escritura en ficheros binarios estructurados (con tipos primitivos): <pre><code>import java.io.DataInputStream\nimport java.io.DataOutputStream\nimport java.io.FileInputStream\nimport java.io.FileOutputStream\nimport java.nio.file.Files\nimport java.nio.file.Path\nfun main() {\n    val ruta = Path.of(\"multimedia/binario.dat\")\n    Files.createDirectories(ruta.parent)\n    // Escritura binaria\n    val fos = FileOutputStream(ruta.toFile())\n    val out = DataOutputStream(fos)\n    out.writeInt(42) // int (4 bytes)\n    out.writeDouble(3.1416) // double (8 bytes)\n    out.writeUTF(\"K\") // char (2 bytes)\n    out.close()\n    fos.close()\n    println (\"Fichero binario escrito con DataOutputStream.\")\n    // Lectura binaria\n    val fis = FileInputStream(ruta.toFile())\n    val input = DataInputStream(fis)\n    val entero = input.readInt()\n    val decimal = input.readDouble()\n    val caracter = input.readUTF()\n    input.close()\n    fis.close()\n    println (\"Contenido le\u00eddo:\")\n    println (\"  Int: $entero\")\n    println (\"  Double: $decimal\")\n    println (\"  Char: $caracter\")\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Fichero binario escrito con DataOutputStream.\nContenido le\u00eddo:\n  Int: 42\n  Double: 3.1416\n  Char: K\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_binarios/#53-ficheros-de-imagenes","title":"5.3. Ficheros de im\u00e1genes","text":"<p>Las im\u00e1genes son ficheros binarios que contienen datos que representan gr\u00e1ficamente una imagen visual (fotograf\u00edas, ilustraciones, etc.). A diferencia de los ficheros de texto o binarios crudos, un fichero de imagen tiene estructura interna que depende del formato.</p> <p>Algunos de los m\u00e1s comunes son: * <code>.jpg</code>: Comprimido con p\u00e9rdida, ideal para fotos. * <code>.png</code>: Comprimido sin p\u00e9rdida, soporta transparencia. * <code>.bmp</code>: Sin compresi\u00f3n, ocupa m\u00e1s espacio. * <code>.gif</code>: Admite animaciones simples, limitada a 256 colores.</p>"},{"location":"unidades/ud02/ficheros_binarios/#metodos-de-ficheros-de-imagenes","title":"M\u00e9todos de Ficheros de Im\u00e1genes","text":"M\u00e9todo Descripci\u00f3n <code>ImageIO.read(Path/File)</code>, <code>ImageIO.write(BufferedImage, ...)</code> Usa <code>javax.imageio.ImageIO</code>."},{"location":"unidades/ud02/ficheros_binarios/#ejemplo-que-genera-una-imagen","title":"Ejemplo que genera una imagen:","text":"<p><pre><code>import java.awt.Color\nimport java.awt.image.BufferedImage\nimport java.io.File\nimport javax.imageio.ImageIO\nfun main() {\n    val ancho = 200\n    val alto = 100\n    val imagen = BufferedImage(ancho, alto, BufferedImage.TYPE_INT_RGB)\n    // Rellenar la imagen con colores\n    for (x in 0 until ancho) {\n        for (y in 0 until alto) {\n            val rojo = (x * 255) / ancho\n            val verde = (y * 255) / alto\n            val azul = 128\n            val color = Color(rojo, verde, azul)\n            imagen.setRGB(x, y, color.rgb)\n        }\n    }\n    // Guardar la imagen\n    val archivo = File(\"multimedia/imagen_generada.png\")\n    ImageIO.write(imagen, \"png\", archivo)\n    println (\"Imagen generada correctamente: ${archivo.absolutePath}\")\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y verifica que se crea la imagen correctamente.</p>"},{"location":"unidades/ud02/ficheros_binarios/#ejemplo-que-convierte-una-imagen-a-escala-de-grises","title":"Ejemplo que convierte una imagen a escala de grises:","text":"<p><pre><code>import java.awt.Color\nimport java.awt.image.BufferedImage\nimport java.nio.file.Files\nimport java.nio.file.Path\nimport java.nio.file.StandardCopyOption\nimport javax.imageio.ImageIO\nfun main() {\n    val originalPath = Path.of(\"multimedia/jpg/amanecer1.jpg\")\n    val copiaPath = Path.of(\"multimedia/jpg/amanecer1_copia.jpg\")\n    val grisPath = Path.of(\"multimedia/jpg/amanecer1_escala_de_grises.png\")\n    // 1. Comprobar si la imagen existe\n    if (!Files.exists(originalPath)) {\n        println (\"No se encuentra la imagen original: $originalPath\")\n    } else {\n        // 2. Copiar la imagen con java.nio (para no modificar el original)\n        Files.copy(originalPath, copiaPath, StandardCopyOption.REPLACE_EXISTING)\n        println (\"Imagen copiada a: $copiaPath\")\n        // 3. Leer la imagen en un objeto BufferedImage\n        val imagen: BufferedImage = ImageIO.read(copiaPath.toFile())\n        // 4. Convertir a escala de grises, p\u00edxel por p\u00edxel\n        for (x in 0 until imagen.width) {\n            for (y in 0 until imagen.height) {\n                // Obtenemos el color del p\u00edxel actual.\n                val color = Color(imagen.getRGB(x, y))\n                /* Calcular el valor de gris usando la f\u00f3rmula de luminosidad.\n                Esta f\u00f3rmula pondera los colores rojo, verde y azul seg\u00fan la sensibilidad del ojo humano.\n                El resultado es un \u00fanico valor de brillo que convertimos a entero. */\n                val gris = (color.red * 0.299 + color.green * 0.587 + color.blue * 0.114).toInt()\n                // Creamos un nuevo color donde los componentes rojo, verde y azul\n                // son todos iguales al valor de 'gris' que hemos calculado.\n                val colorGris = Color(gris, gris, gris)\n                // Establecemos el nuevo color gris en el p\u00edxel de la imagen.\n                imagen.setRGB(x, y, colorGris.rgb)\n            }\n        }\n        // 5. Guardar la imagen modificada\n        // Usamos \"png\" porque es un formato sin p\u00e9rdida, ideal para im\u00e1genes generadas.\n        ImageIO.write(imagen, \"png\", grisPath.toFile())\n        println (\"Imagen convertida a escala de grises y guardada como: $grisPath\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y verifica que la imagen generada es la misma que la original pero en tonos de grises.</p>"},{"location":"unidades/ud02/ficheros_directorios/","title":"Ficheros y directorios","text":""},{"location":"unidades/ud02/ficheros_directorios/#2-gestion-de-ficheros-y-directorios","title":"2. Gesti\u00f3n de ficheros y directorios","text":"<p>La gesti\u00f3n de ficheros y directorios se realiza a trav\u00e9s de Path y Files.</p> <ul> <li>Path: Representa una ruta en el sistema de ficheros (ej. <code>/home/usuario/foto.png</code> o <code>C:\\usuarios\\docs\\informe.txt</code>). Un objeto Path es una direcci\u00f3n y no significa que el fichero o directorio exista.</li> </ul>"},{"location":"unidades/ud02/ficheros_directorios/#metodos-principales-de-path","title":"M\u00e9todos principales de Path","text":"M\u00e9todo Descripci\u00f3n <code>Path.of(String)</code> Crea un objeto <code>Path</code> a partir de un String de ruta (Java 11+). Por debajo llama a <code>Paths.get()</code> que es el m\u00e9todo original de la clase <code>Paths</code> (Java 7+). <code>toString()</code> Devuelve la ruta como un <code>String</code> (se llama por defecto desde <code>println</code>). <code>toAbsolutePath()</code> Devuelve la ruta absoluta del Path. <code>fileName()</code> Devuelve el nombre del fichero o directorio final de la ruta."},{"location":"unidades/ud02/ficheros_directorios/#ejemplo-1","title":"Ejemplo 1","text":"<p><pre><code>import java.nio.file.Path\nfun main() {\n    // Path relativo al directorio del proyecto\n    val rutaRelativa: Path = Path.of(\"documentos\", \"ejemplo.txt\")\n    // Path absoluto en Windows\n    val rutaAbsolutaWin: Path = Path.of(\"C:\", \"Users\", \"Pol\", \"Documentos\")\n    // Path absoluto en Linux/macOS\n    val rutaAbsolutaNix: Path = Path.of(\"/home/pol/documentos\")\n    println (\"Ruta relativa: \" + rutaRelativa)\n    println (\"Ruta absoluta: \" + rutaRelativa.toAbsolutePath())\n    println (\"Ruta absoluta: \" + rutaAbsolutaWin)\n    println (\"Ruta absoluta: \" + rutaAbsolutaNix)\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Ruta relativa: documentos\\ejemplo.txt\nRuta absoluta: F:\\kot\\1-ficheros\\documentos\\ejemplo.txt\nRuta absoluta: C:\\Users\\Pol\\Documentos\nRuta absoluta: \\home\\pol\\documentos\n</code></pre></p> <ul> <li>Files: Es una clase de utilidad con las acciones (borrar, copiar, mover, leer, etc) que podemos realizar sobre las rutas (<code>Path</code>).</li> </ul>"},{"location":"unidades/ud02/ficheros_directorios/#metodos-principales-de-files","title":"M\u00e9todos principales de Files","text":"M\u00e9todo Descripci\u00f3n <code>exists()</code>, <code>isDirectory()</code>, <code>isRegularFile()</code>, <code>isReadable()</code> Verificar de existencia y accesibilidad. <code>list()</code>, <code>walk()</code> Listar contenido de un directorio. <code>readAttributes()</code> Obtener atributos (tama\u00f1o, fecha, etc.). <code>createDirectory()</code> Crear un directorio: Solo crea el directorio y espera que todo el \"camino\" hasta \u00e9l ya exista. <code>createDirectories</code> Crea un directorio y tambi\u00e9n los directorios padre si no existen. Es la forma m\u00e1s segura. <code>createFile()</code> Crear un fichero. <code>delete()</code> Borrar un fichero o directorio (lanza una excepci\u00f3n si el borrado falla). Lanza la excepci\u00f3n <code>NoSuchFileException</code> si el fichero o directorio no existe. Es m\u00e1s seguro <code>deleteIfExists()</code>. <code>move(origen, destino)</code> Mover o renombrar un fichero o directorio. <code>copy(origen, destino)</code> Copiar un fichero o directorio. Si el destino ya existe se puede sobreescribir utilizando <code>copy(Path, Path, REPLACE_EXISTING)</code>. Si se copia un directorio no se copiar\u00e1 su contenido, el nuevo directorio estar\u00e1 vac\u00edo."},{"location":"unidades/ud02/ficheros_directorios/#ejemplo-2","title":"Ejemplo 2","text":"<p>El siguiente ejemplo es un organizador de ficheros. Imagina una carpeta de \"multimedia\" donde todo est\u00e1 desordenado. El programa organizar\u00e1 los ficheros en subcarpetas seg\u00fan su extensi\u00f3n (.pdf, .jpg, .mp3, etc).</p> <p><pre><code>import java.nio.file.Files\nimport java.nio.file.Path\nimport java.nio.file.StandardCopyOption\nimport kotlin.io.path.extension // Extensi\u00f3n de Kotlin para obtener la extensi\u00f3n\nfun main() {\n    // 1. Ruta de la carpeta a organizar\n    val carpeta = Path.of(\"multimedia\")\n    println (\"--- Iniciando la organizaci\u00f3n de la carpeta: \" + carpeta + \"---\")\n    try {\n        // 2. Recorrer la carpeta desordenada y utilizar .use para asegurar que los recursos del sistema se cierren correctamente\n        Files.list(carpeta).use { streamDePaths -&gt;\n            streamDePaths.forEach { pathFichero -&gt;\n                // 3. Solo interesan los ficheros, ignorar subcarpetas\n                if (Files.isRegularFile(pathFichero)) {\n                    // 4. Obteners la extensi\u00f3n del fichero (ej: \"pdf\", \"jpg\")\n                    val extension = pathFichero.extension.lowercase()\n                    if (extension.isBlank()) {\n                        println (\"-&gt; Ignorando: \" + pathFichero.fileName)\n                        return@forEach // Salta a la siguiente iteraci\u00f3n del bucle\n                    }\n                    // 5. Crear la ruta del directorio de destino\n                    val carpetaDestino = carpeta.resolve(extension)\n                    // 6. Crear el directorio de destino si no existe\n                    if (Files.notExists(carpetaDestino)) {\n                        println (\"-&gt; Creando nueva carpeta \" + extension)\n                        Files.createDirectories(carpetaDestino)\n                    }\n                    // 7. Mover el fichero a su nueva carpeta\n                    val pathDestino = carpetaDestino.resolve(pathFichero.fileName)\n                    Files.move(pathFichero, pathDestino, StandardCopyOption.REPLACE_EXISTING)\n                    println (\"-&gt; Moviendo \" + pathFichero.fileName + \" a \" + extension)\n                }\n            }\n        }\n        println (\"\\n--- \u00a1Organizaci\u00f3n completada con \u00e9xito! ---\")\n    } catch (e: Exception) {\n        println (\"\\n--- Ocurri\u00f3 un error durante la organizaci\u00f3n ---\")\n        e.printStackTrace()\n    }\n}\n</code></pre> \ud83d\udd0d Crea una carpeta, dentro de tu proyecto llamada <code>multimedia</code> y guarda diferentes archivos (pdf, jpg, txt, etc.). Ejecuta el ejemplo anterior y comprueba que la salida es parecida a la siguiente.</p> <pre><code>--- Iniciando la organizaci\u00f3n de la carpeta: multimedia---\n-&gt; Creando nueva carpeta jpg\n-&gt; Moviendo 20191106_071048.jpg a jpg\n-&gt; Moviendo 20191101_071830.jpg a jpg\n-&gt; Creando nueva carpeta txt\n-&gt; Moviendo libros.txt a txt\n-&gt; Moviendo peliculas.txt a txt\n-&gt; Creando nueva carpeta pdf\n-&gt; Moviendo lorem-ipsum-2.pdf a pdf\n-&gt; Moviendo lorem-ipsum-1.pdf a pdf\n-&gt; Creando nueva carpeta mp3\n-&gt; Moviendo dark-cinematic-atmosphere.mp3 a mp3\n-&gt; Moviendo pad-harmonious-and-soothing-voice-like-background.mp3 a mp3\n\n--- \u00a1Organizaci\u00f3n completada con \u00e9xito! ---\n</code></pre> <p>En el ejemplo anterior hemos recorrido un directorio para organizar los ficheros que conten\u00eda. Recorrer un directorio para \"mirar\" su contenido es \u00fatil en muchas situaciones y hay varias formas de hacerlo. A continuaci\u00f3n veremos algunas:</p> <ul> <li><code>Files.list(path)</code>: Es la utilizada en el ejemplo anterior. Lista \u00fanicamente el contenido de un directorio sin acceder a las subcarpetas. Ser\u00e1 \u00fatil cuando solamente sea necesario acceder al contenido directo de una carpeta, por ejemplo para organizar ficheros en un directorio, mostrar el contenido de la carpeta actual o buscar un fichero espec\u00edfico solo en este nivel.<ul> <li>Ventajas:<ul> <li>R\u00e1pido y eficiente al no ser recursivo.</li> <li>Ofrece un control preciso, operando solo en el primer nivel del directorio.</li> <li>Devuelve un <code>Stream</code> de Java que permite usar operadores funcionales (<code>filter</code>, <code>map</code>, etc.) de forma segura con <code>.use</code>.</li> </ul> </li> <li>Inconvenientes:<ul> <li>No explora subdirectorios.</li> <li>Para recorrer un \u00e1rbol completo, se necesita implementar l\u00f3gica recursiva manualmente.</li> </ul> </li> </ul> </li> <li><code>Files.walk(path)</code>: Recorre un directorio y todo su contenido recursivamente. Entra en cada subcarpeta, y en sus subcarpetas hasta el final. Ser\u00e1 \u00fatil para operar sobre un directorio y todo lo que contiene, sin importar la profundidad, por ejemplo para buscar un fichero por nombre en cualquier subcarpeta, eliminar todos los ficheros temporales de un proyecto o contar todos los ficheros .kt de un repositorio.<ul> <li>Ventajas:<ul> <li>Recorre \u00e1rboles de directorios completos (recursivo) de forma muy sencilla.</li> <li>Extremadamente potente para b\u00fasquedas profundas o aplicar operaciones a todos los elementos anidados.</li> <li>Tambi\u00e9n devuelve un <code>Stream</code>, permitiendo un filtrado y procesamiento muy expresivo.</li> </ul> </li> <li>Inconvenientes:<ul> <li>Puede ser lento y consumir m\u00e1s memoria en directorios con miles de ficheros.</li> <li>Es una herramienta excesiva ('overkill') para tareas que solo requieren acceder al nivel actual.</li> </ul> </li> </ul> </li> <li><code>Files.newDirectoryStream(path)</code>: Es similar a <code>Files.list()</code>, listando solo el contenido inmediato. La diferencia es que no devuelve un <code>Stream</code> de Java 8 (que permite usar <code>.filter</code>, <code>.forEach</code>, etc.), sino un <code>DirectoryStream</code>, que es una versi\u00f3n m\u00e1s antigua que se usa con bucles for. Es menos com\u00fan en c\u00f3digo Kotlin moderno, pero es bueno reconocerlo para poder entender en proyectos antiguos (legacy). Para cualquier tarea nueva, <code>Files.list()</code> y <code>Files.walk()</code> son superiores en seguridad y expresividad.<ul> <li>Ventajas:<ul> <li>Utiliza un bucle <code>for-each</code> tradicional, que puede resultar familiar.</li> </ul> </li> <li>Inconvenientes:<ul> <li>\u00a1PELIGRO! Requiere cerrar el recurso manualmente (<code>.close()</code>). Si se olvida, provoca fugas de recursos (<code>resource leaks</code>).</li> <li>Es menos expresivo que los Streams. No se pueden encadenar operadores funcionales f\u00e1cilmente.</li> <li>Considerado obsoleto en c\u00f3digo Kotlin idiom\u00e1tico, que prefiere <code>Files.list().use{...}</code>.</li> </ul> </li> </ul> </li> </ul>"},{"location":"unidades/ud02/ficheros_directorios/#ejemplo-3","title":"Ejemplo 3","text":"<p>Queremos crear un informe de toda la estructura de la carpeta resultante del ejemplo anterior. Por tanto necesitamos entrar en las nuevas carpetas (pdf, jpg, txt) y ver qu\u00e9 ficheros hay dentro de cada una. Para ello se utiliza <code>Files.walk()</code> que calcula la profundidad, recorre la jerarqu\u00eda de carpetas y muestra cada elemento indicando si es un directorio o un fichero.</p> <p><pre><code>import java.nio.file.Files\nimport java.nio.file.Path\nfun main() {\n    val carpetaPrincipal = Path.of(\"multimedia\")\n    println (\"--- Mostrando la estructura final con Files.walk() ---\")\n    try {\n        Files.walk(carpetaPrincipal).use { stream -&gt;\n            // Ordenar el stream para una visualizaci\u00f3n m\u00e1s predecible\n            stream.sorted().forEach { path -&gt;\n                // Calcular profundidad para la indentaci\u00f3n\n                // Restamos el n\u00famero de componentes de la ruta base para que el directorio principal no tenga indentaci\u00f3n\n                val profundidad = path.nameCount - carpetaPrincipal.nameCount\n                val indentacion = \"\\t\".repeat(profundidad)\n                // Determinamos si es directorio o fichero para el prefijo\n                val prefijo = if (Files.isDirectory(path)) \"[DIR]\" else \"[FILE]\"\n                // No imprimimos la propia carpeta ra\u00edz, solo su contenido\n                if (profundidad &gt; 0) {\n                    println (\"$indentacion$prefijo ${path.fileName}\")\n                }\n            }\n        }\n    } catch (e: Exception) {\n        println (\"\\n--- Ocurri\u00f3 un error durante el recorrido ---\")\n        e.printStackTrace()\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>--- Mostrando la estructura final con Files.walk() ---\n    [DIR] jpg\n        [FILE] 20191101_071830.jpg\n        [FILE] 20191106_071048.jpg\n    [DIR] mp3\n        [FILE] dark-cinematic-atmosphere.mp3\n        [FILE] pad-harmonious-and-soothing-voice-like-background.mp3\n    [DIR] mp4\n        [FILE] 283533_small.mp4\n        [FILE] 293968_small.mp4\n    [DIR] pdf\n        [FILE] lorem-ipsum-1.pdf\n        [FILE] lorem-ipsum-2.pdf\n    [DIR] txt\n        [FILE] libros.txt\n        [FILE] peliculas.txt\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_directorios/#practica-2-directorios-y-comprobaciones","title":"\ud83c\udfaf Pr\u00e1ctica 2: Directorios y comprobaciones","text":"<p>Prepara la estructura de tu proyecto. Crea la carpeta <code>datos</code>. Bas\u00e1ndote en los ejemplos anteriores, desarrolla un programa en tu proyecto haga lo siguiente:</p> <ul> <li>Define dos rutas: una para una carpeta llamada <code>datos_ini</code> y otra para una carpeta llamada <code>datos_fin</code> (ambas dentro de la carpeta de tu proyecto).</li> <li>Comprueba los directorios: Si las carpetas no existen las deber\u00e1 crear utilizando <code>Files.createDirectories</code>.</li> <li>A\u00f1ade ficheros: A\u00f1ade (manualmente y vac\u00edo) el fichero <code>mis_datos.json</code> dentro de la carpeta <code>datos_ini</code>.</li> <li>Comprueba ficheros: Despu\u00e9s de la comprobaci\u00f3n de la existencia del fichero de datos dentro de la carpeta <code>datos_ini</code> (<code>mis_datos.json</code>) imprimir\u00e1 un mensaje por consola mostrando la estrctura de directorios y ficheros.</li> </ul>"},{"location":"unidades/ud02/ficheros_intercambio/","title":"Ficheros de intercambio","text":""},{"location":"unidades/ud02/ficheros_intercambio/#4-ficheros-de-intercambio-de-informacion","title":"4. Ficheros de intercambio de informaci\u00f3n","text":"<p>Los ficheros de texto en los que la informaci\u00f3n est\u00e1 estructurada y organizada de una manera predecible permiten que distintos sistemas la lean y entiendan. Estos tipos de ficheros se utilizan en el desarrollo de software para intercambiar informaci\u00f3n entre aplicaciones y algunos de los formatos m\u00e1s importantes son CSV, JSON y XML.</p> <p>Para poder llevar a cabo este intercambio de informaci\u00f3n, hay que extraer la informaci\u00f3n del fichero origen. Este proceso no se realiza l\u00ednea por l\u00ednea, sino que el contenido del fichero se lee (parsea) utilizando la t\u00e9cnica de serializaci\u00f3n/deserializaci\u00f3n:</p> <ul> <li>Serializaci\u00f3n: Proceso de convertir un objeto en memoria (por ejemplo, una data class) en una representaci\u00f3n textual o binaria (como un String en formato JSON o XML) que se puede guardar en un fichero o enviar por red.</li> <li>Deserializaci\u00f3n: Es el proceso inverso de leer un fichero (JSON, XML, etc.) y reconstruir el objeto original en memoria para poder trabajar con \u00e9l.</li> </ul> <p>A continuaci\u00f3n se muestra una tabla con clases y herramientas que se utilizan para serializar / deserializar:</p>"},{"location":"unidades/ud02/ficheros_intercambio/#metodos-de-serializaciondeserializacion","title":"M\u00e9todos de Serializaci\u00f3n/Deserializaci\u00f3n","text":"M\u00e9todo Descripci\u00f3n <code>java.io.Serializable</code> Marca que un objeto es serializable. <code>ObjectOutputStream</code> Serializa y escribe un objeto. <code>ObjectInputStream</code> Lee un objeto serializado. <code>@transient</code> Excluye atributos de la serializaci\u00f3n. <code>ReadObject</code> Lee y reconstruye un objeto binario. <code>WriteObject</code> Guarda un objeto como binario. <code>@Serializable</code> Permite convertir el data class a JSON y viceversa."},{"location":"unidades/ud02/ficheros_intercambio/#ejemplo-serializar-y-deserializar-un-objeto-usando-transient","title":"Ejemplo - Serializar y deserializar un objeto (usando <code>@Transient</code>):","text":"<p><pre><code>import java.io.*\n// Clase Persona (serializable completamente)\nclass Persona(val nombre: String, val edad: Int) : Serializable\n// Clase Usuario con un atributo que NO se serializa\nclass Usuario(\n    val nombre: String,\n    @Transient val clave: String // Este campo no se guardar\u00e1\n) : Serializable\nfun main() {\n    val rutaPersona = \"multimedia/persona.obj\"\n    val rutaUsuario = \"multimedia/usuario.obj\"\n    // Asegurar que el directorio exista\n    val directorio = File(\"documentos\")\n    if (!directorio.exists()) {\n        directorio.mkdirs()\n    }\n    // --- Serializar Persona ---\n    val persona = Persona(\"Pol\", 30)\n    try {\n        ObjectOutputStream(FileOutputStream(rutaPersona)).use { oos -&gt;\n            oos.writeObject(persona)\n        }\n        println (\"Persona serializada.\")\n    } catch (e: IOException) {\n        println (\"Error al serializar Persona: ${e.message}\")\n    }\n    // --- Deserializar Persona ---\n    try {\n        val personaLeida = ObjectInputStream(FileInputStream(rutaPersona)).use { ois -&gt;\n            ois.readObject() as Persona\n        }\n        println (\"Persona deserializada:\")\n        println (\"Nombre: ${personaLeida.nombre}, Edad: ${personaLeida.edad}\")\n    } catch (e: Exception) {\n        println (\"Error al deserializar Persona: ${e.message}\")\n    }\n    // --- Serializar Usuario ---\n    val usuario = Usuario(\"Eli\", \"1234\")\n    try {\n        ObjectOutputStream(FileOutputStream(rutaUsuario)).use { oos -&gt;\n            oos.writeObject(usuario)\n        }\n        println (\"Usuario serializado.\")\n    } catch (e: IOException) {\n        println (\"Error al serializar Usuario: ${e.message}\")\n    }\n    // --- Deserializar Usuario ---\n    try {\n        val usuarioLeido = ObjectInputStream(FileInputStream(rutaUsuario)).use { ois -&gt;\n            ois.readObject() as Usuario\n        }\n        println (\"Usuario deserializado:\")\n        println (\"Nombre: ${usuarioLeido.nombre}, Clave: ${usuarioLeido.clave}\")\n    } catch (e: Exception) {\n        println (\"Error al deserializar Usuario: ${e.message}\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Persona serializada.\nPersona deserializada:\nNombre: Pol, Edad: 30\nUsuario serializado.\nUsuario deserializado:\nNombre: Eli, Clave: null\n</code></pre></p> <p>A continuaci\u00f3n se describen los 3 tipos de ficheros m\u00e1s comunes para intercambio de informaci\u00f3n. Se muestran ejemplos de lectura y escritura usando serializaci\u00f3n y deserializaci\u00f3n utilizando un proyecto con Gradle:</p>"},{"location":"unidades/ud02/ficheros_intercambio/#41-csv-comma-separated-values","title":"4.1. CSV (Comma-Separated Values)","text":"<p>Son ficheros de texto plano con valores separados por un delimitador (coma, punto y coma, etc.). Son \u00fatiles para exportar/importar datos desde Excel, Google Sheets, o bases de datos. Se manejan con herramientas como OpenCSV (m\u00e1s antigua) o Kotlin-CSV (la que utilizaremos).</p>"},{"location":"unidades/ud02/ficheros_intercambio/#metodos-de-kotlin-csv","title":"M\u00e9todos de Kotlin-CSV","text":"M\u00e9todo Ejemplo <code>readAll(File)</code> <code>val filas = csvReader().readAll(File(\"alumnos.csv\"))</code> <code>readAllWithHeader(File)</code> <code>val datos = csvReader().readAllWithHeader(File(\"alumnos.csv\"))</code> <code>open { readAllAsSequence() }</code> <code>csvReader().open(\"alumnos.csv\") { readAllAsSequence().forEach { println(it) } }</code> <code>writeAll(data, File)</code> <code>csvWriter().writeAll(listOf(listOf(\"Pol\", \"9\")), File(\"salida.csv\"))</code> <code>writeRow(row, File)</code> <code>csvWriter().writeRow(listOf(\"Ade\", \"8\"), File(\"salida.csv\"))</code> <code>writeAllWithHeader(data, File)</code> <code>csvWriter().writeAllWithHeader(listOf(mapOf(\"nombre\" to \"Eli\", \"nota\" to \"10\")), File(\"salida.csv\"))</code> <code>delimiter</code>, <code>quoteChar</code>, etc. <code>csvReader { delimiter = ';' }</code>"},{"location":"unidades/ud02/ficheros_intercambio/#ejemplo-de-lectura-y-escritura-de-ficheros-csv","title":"Ejemplo de lectura y escritura de ficheros CSV:","text":"<p>Partimos de un fichero llamado <code>mis_plantas.csv</code> con la informaci\u00f3n siguiente: <pre><code>1;Aloe Vera;Aloe barbadensis miller;7;0.6\n2;Lavanda;Lavandula angustifolia;3;1.0\n3;Helecho de Boston;Nephrolepis exaltata;5;0.9\n4;Bamb\u00fa de la suerte;Dracaena sanderiana;4;1.5\n5;Girasol;Helianthus annuus;2;3.0\n</code></pre> Donde los campos corresponden a: * <code>id_planta</code> (int) * <code>nombre_comun</code> (string) * <code>nombre_cientifico</code> (string) * <code>frecuencia_riego</code> (int) * <code>altura_m\u00e1xima</code> (double)</p> <p>Utilizaremos la librer\u00eda Kotlin-CSV. Por tanto habr\u00e1 que indicarlo en el fichero <code>build.gradle.kts</code> a\u00f1adiendo las siguientes l\u00edneas:</p> <ul> <li>En <code>plugins</code>: <pre><code>kotlin(\"plugin.serialization\") version \"1.9.0\"\n</code></pre></li> <li>En <code>dependencies</code>: <pre><code>implementation(\"com.github.doyaaaaaken:kotlin-csv-jvm:1.9.1\")\n</code></pre></li> </ul> <p><pre><code>import java.nio.file.Files\nimport java.nio.file.Path\nimport java.io.File\n// Librer\u00eda espec\u00edfica de Kotlin para leer y escribir ficheros CSV.\nimport com.github.doyaaaaaken.kotlincsv.dsl.csvReader\nimport com.github.doyaaaaaken.kotlincsv.dsl.csvWriter\n//Usamos una 'data class' para representar la estructura de una planta.\ndata class Planta(val id_planta: Int, val nombre_comun: String, val nombre_cientifico: String, val riego: Int, val altura: Double)\nfun main() {\n    val entradaCSV = Path.of(\"datos_ini/mis_plantas.csv\")\n    val salidaCSV = Path.of(\"datos_ini/mis_plantas2.csv\")\n    val datos: List&lt;Planta&gt;\n    datos = leerDatosInicialesCSV(entradaCSV)\n    for (dato in datos) {\n        println (\"  - ID: ${dato.id_planta}, Nombre com\u00fan: ${dato.nombre_comun}, Nombre cient\u00edfico: ${dato.nombre_cientifico}, Frecuencia de riego: ${dato.riego} d\u00edas, Altura: ${dato.altura} metros\")\n    }\n    escribirDatosCSV(salidaCSV, datos)\n}\nfun leerDatosInicialesCSV(ruta: Path): List&lt;Planta&gt; {\n    var plantas: List&lt;Planta&gt; = emptyList()\n    // Comprobar si el fichero es legible antes de intentar procesarlo.\n    if (!Files.isReadable(ruta)) {\n        println (\"Error: No se puede leer el fichero en la ruta: $ruta\")\n    } else {\n        // Configuramos el lector de CSV con el delimitador\n        val reader = csvReader {\n            delimiter = ';'\n        }\n        /* Leemos TODO el fichero CSV.\n        El resultado es una lista de listas de Strings (`List&lt;List&lt;String&gt;&gt;`),\n        donde cada lista interna representa una fila del fichero.*/\n        val filas: List&lt;List&lt;String&gt;&gt; = reader.readAll(ruta.toFile())\n        /* Convertir la lista de texto plano en una lista de objetos 'Planta'.\n        `mapNotNull` funciona como un `map` y descartando todos los `null` de la lista final.\n        Si una fila del CSV es inv\u00e1lida, devolvemos `null`\n        y `mapNotNull` se encarga de ignorarla. */\n        plantas = filas.mapNotNull { columnas -&gt;\n            // Validar si La fila tiene al menos 4 columnas.\n            if (columnas.size &gt;= 5) {\n                try {\n                    val id_planta = columnas[0].toInt()\n                    val nombre_comun = columnas[1]\n                    val nombre_cientifico = columnas[2]\n                    val riego = columnas[3].toInt()\n                    val altura = columnas[4].toDouble()\n                    Planta(id_planta,nombre_comun, nombre_cientifico, riego, altura) //crear el objeto Planta\n                } catch (e: Exception) {\n                    /* Si ocurre un error en la conversi\u00f3n (ej: NumberFormatException),\n                    capturamos la excepci\u00f3n, imprimimos un aviso (opcional)\n                    y devolvemos `null` para que `mapNotNull` descarte esta fila. */\n                    println (\"Fila inv\u00e1lida ignorada: $columnas -&gt; Error: ${e.message}\")\n                    null\n                }\n            } else {\n                // Si la fila no tiene suficientes columnas, es inv\u00e1lida. Devolvemos null.\n                println (\"Fila con formato incorrecto ignorada: $columnas\")\n                null\n            }\n        }\n    }\n    return plantas\n}\nfun escribirDatosCSV(ruta: Path,plantas: List&lt;Planta&gt;){\n    try {\n        val fichero: File = ruta.toFile()\n        csvWriter {\n            delimiter = ';'\n        }.writeAll(\n            plantas.map { planta -&gt;\n                listOf (planta.id_planta.toString(),\n                    planta.nombre_comun,\n                    planta.nombre_cientifico,\n                    planta.riego.toString(),\n                    planta.altura.toString())\n            } ,\n            fichero\n        )\n        println (\"\\nInformaci\u00f3n guardada en: $fichero\")\n    } catch (e: Exception) {\n        println (\"Error: ${e.message}\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior, comprueba que la salida es la siguiente, que se ha creado el fichero <code>mis_plantas2.csv</code> y que su contenido es correcto: <pre><code>  - ID: 1, Nombre com\u00fan: Aloe Vera, Nombre cient\u00edfico: Aloe barbadensis miller, Frecuencia de riego: 7 d\u00edas, Altura: 0.6 metros\n  - ID: 2, Nombre com\u00fan: Lavanda, Nombre cient\u00edfico: Lavandula angustifolia, Frecuencia de riego: 3 d\u00edas, Altura: 1.0 metros\n  - ID: 3, Nombre com\u00fan: Helecho de Boston, Nombre cient\u00edfico: Nephrolepis exaltata, Frecuencia de riego: 5 d\u00edas, Altura: 0.9 metros\n  - ID: 4, Nombre com\u00fan: Bamb\u00fa de la suerte, Nombre cient\u00edfico: Dracaena sanderiana, Frecuencia de riego: 4 d\u00edas, Altura: 1.5 metros\n  - ID: 5, Nombre com\u00fan: Girasol, Nombre cient\u00edfico: Helianthus annuus, Frecuencia de riego: 2 d\u00edas, Altura: 3.0 metros\n\nInformaci\u00f3n guardada en: datos_ini\\mis_plantas2.csv\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_intercambio/#42-xml-extensible-markup-language","title":"4.2. XML (eXtensible Markup Language)","text":"<p>Los ficheros XML son muy estructurados y extensibles. Se basan en etiquetas anidadas similar a HTML. Permiten la validaci\u00f3n de datos (mediante esquemas XSD) y es ideal para integraci\u00f3n con sistemas empresariales (legacy). Se manejan con librer\u00edas como JAXB, DOM, JDOM2 o Jackson XML (XmlMapper) que es la que utilizaremos.</p>"},{"location":"unidades/ud02/ficheros_intercambio/#metodos-de-jackson-xml","title":"M\u00e9todos de Jackson XML","text":"M\u00e9todo Descripci\u00f3n <code>readValue(File, Class&lt;T&gt;)</code> Lee un fichero XML y lo convierte en un objeto Kotlin/Java. <code>readValue(String, Class&lt;T&gt;)</code> Lee un String XML y lo convierte en un objeto. <code>writeValue(File, Object)</code> Escribe un objeto como XML en un fichero. <code>writeValueAsString(Object)</code> Convierte un objeto en una cadena XML. <code>writeValueAsBytes(Object)</code> Convierte un objeto en un array de bytes XML. <code>registerModule(Module)</code> Registra un m\u00f3dulo como <code>KotlinModule</code> o <code>JavaTimeModule</code>. <code>enable(SerializationFeature)</code> Activa una opci\u00f3n de serializaci\u00f3n (por ejemplo, indentado). <code>disable(DeserializationFeature)</code> Desactiva una opci\u00f3n de deserializaci\u00f3n. <code>configure(MapperFeature, boolean)</code> Configura opciones generales del mapeo. <code>setDefaultPrettyPrinter(...)</code> Establece un formateador personalizado."},{"location":"unidades/ud02/ficheros_intercambio/#ejemplo-de-lectura-y-escritura-de-ficheros-xml","title":"Ejemplo de lectura y escritura de ficheros XML:","text":"<p>Partimos de un fichero llamado <code>mis_plantas.xml</code> con la informaci\u00f3n siguiente: <pre><code>&lt;plantas&gt;\n  &lt;planta&gt;\n    &lt;id_planta&gt;1&lt;/id_planta&gt;\n    &lt;nombre_comun&gt;Aloe Vera&lt;/nombre_comun&gt;\n    &lt;nombre_cientifico&gt;Aloe barbadensis miller&lt;/nombre_cientifico&gt;\n    &lt;frecuencia_riego&gt;7&lt;/frecuencia_riego&gt;\n    &lt;altura_maxima&gt;0.6&lt;/altura_maxima&gt;\n  &lt;/planta&gt;\n  &lt;planta&gt;\n    &lt;id_planta&gt;2&lt;/id_planta&gt;\n    &lt;nombre_comun&gt;Lavanda&lt;/nombre_comun&gt;\n    &lt;nombre_cientifico&gt;Lavandula angustifolia&lt;/nombre_cientifico&gt;\n    &lt;frecuencia_riego&gt;3&lt;/frecuencia_riego&gt;\n    &lt;altura_maxima&gt;1.0&lt;/altura_maxima&gt;\n  &lt;/planta&gt;\n  &lt;planta&gt;\n    &lt;id_planta&gt;3&lt;/id_planta&gt;\n    &lt;nombre_comun&gt;Helecho de Boston&lt;/nombre_comun&gt;\n    &lt;nombre_cientifico&gt;Nephrolepis exaltata&lt;/nombre_cientifico&gt;\n    &lt;frecuencia_riego&gt;5&lt;/frecuencia_riego&gt;\n    &lt;altura_maxima&gt;0.9&lt;/altura_maxima&gt;\n  &lt;/planta&gt;\n  &lt;planta&gt;\n    &lt;id_planta&gt;4&lt;/id_planta&gt;\n    &lt;nombre_comun&gt;Bamb\u00fa de la suerte&lt;/nombre_comun&gt;\n    &lt;nombre_cientifico&gt;Dracaena sanderiana&lt;/nombre_cientifico&gt;\n    &lt;frecuencia_riego&gt;4&lt;/frecuencia_riego&gt;\n    &lt;altura_maxima&gt;1.5&lt;/altura_maxima&gt;\n  &lt;/planta&gt;\n  &lt;planta&gt;\n    &lt;id_planta&gt;5&lt;/id_planta&gt;\n    &lt;nombre_comun&gt;Girasol&lt;/nombre_comun&gt;\n    &lt;nombre_cientifico&gt;Helianthus annuus&lt;/nombre_cientifico&gt;\n    &lt;frecuencia_riego&gt;2&lt;/frecuencia_riego&gt;\n    &lt;altura_maxima&gt;3.0&lt;/altura_maxima&gt;\n  &lt;/planta&gt;\n&lt;/plantas&gt;\n</code></pre> Utilizaremos la librer\u00eda Jackson XML. Por tanto habr\u00e1 que indicarlo en el fichero <code>build.gradle.kts</code> a\u00f1adiendo las siguientes l\u00edneas: <pre><code>implementation (\"com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.17.0\")\nimplementation (\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.0\")\n</code></pre></p> <p><pre><code>import java.nio.file.Path\nimport java.io.File\n// Anotaciones y clases de la librer\u00eda Jackson para el mapeo a XML.\nimport com.fasterxml.jackson.dataformat.xml.XmlMapper\nimport com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement\nimport com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper\nimport com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty\nimport com.fasterxml.jackson.module.kotlin.readValue\nimport com.fasterxml.jackson.module.kotlin.registerKotlinModule\n/*Representa la estructura de una \u00fanica planta. La propiedad 'id_planta' ser\u00e1 la etiqueta &lt;id_planta&gt;...&lt;/id_planta&gt; (as\u00ed todas) */\ndata class Planta(\n    @JacksonXmlProperty(localName = \"id_planta\")\n    val id_planta: Int,\n    @JacksonXmlProperty(localName = \"nombre_comun\")\n    val nombre_comun: String,\n    @JacksonXmlProperty(localName = \"nombre_cientifico\")\n    val nombre_cientifico: String,\n    @JacksonXmlProperty(localName = \"frecuencia_riego\")\n    val frecuencia_riego: Int,\n    @JacksonXmlProperty(localName = \"altura_maxima\")\n    val altura_maxima: Double\n)\n//nombre del elemento ra\u00edz\n@JacksonXmlRootElement(localName = \"plantas\")\n// Data class que representa el elemento ra\u00edz del XML.\ndata class Plantas(\n    @JacksonXmlElementWrapper(useWrapping = false) // No necesitamos la etiqueta &lt;plantas&gt; aqu\u00ed\n    @JacksonXmlProperty(localName = \"planta\")\n    val listaPlantas: List&lt;Planta&gt; = emptyList()\n)\nfun main() {\n    val entradaXML = Path.of(\"datos_ini/mis_plantas.xml\")\n    val salidaXML = Path.of(\"datos_ini/mis_plantas2.xml\")\n    val datos: List&lt;Planta&gt;\n    datos = leerDatosInicialesXML(entradaXML)\n    for (dato in datos) {\n        println (\"  - ID: ${dato.id_planta}, Nombre com\u00fan: ${dato.nombre_comun}, Nombre cient\u00edfico: ${dato.nombre_cientifico}, Frecuencia de riego: ${dato.frecuencia_riego} d\u00edas, Altura: ${dato.altura_maxima} metros\")\n    }\n    escribirDatosXML(salidaXML, datos)\n}\nfun leerDatosInicialesXML(ruta: Path): List&lt;Planta&gt; {\n    val fichero: File = ruta.toFile()\n    // Deserializar el XML a objetos Kotlin\n    val xmlMapper = XmlMapper().registerKotlinModule()\n    // 'readValue' convierte el contenido XML en una instancia de la clase 'Plantas'\n    val plantasWrapper: Plantas = xmlMapper.readValue(fichero)\n    return plantasWrapper.listaPlantas\n}\nfun escribirDatosXML(ruta: Path,plantas: List&lt;Planta&gt;) {\n    try {\n        val fichero: File = ruta.toFile()\n        // Creamos instancia de la clase 'Plantas' (ra\u00edz del XML).\n        val contenedorXml = Plantas(plantas)\n        // Configuramos el 'XmlMapper' (motor de Jackson) para la conversi\u00f3n a XML.\n        val xmlMapper = XmlMapper().registerKotlinModule()\n        // Convertimos 'contenedorXml' en un String con formato XML.\n        // .writerWithDefaultPrettyPrinter() formatea con indentaci\u00f3n y saltos de l\u00ednea\n        val xmlString = xmlMapper.writerWithDefaultPrettyPrinter().writeValueAsString(contenedorXml)\n        // escribir un String en un fichero con 'writeText'\n        fichero.writeText(xmlString)\n        println (\"\\nInformaci\u00f3n guardada en: $fichero\")\n    } catch (e: Exception) {\n        println (\"Error: ${e.message}\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior, comprueba que la salida es la siguiente, que se ha creado el fichero <code>mis_plantas2.xml</code> y que su contenido es correcto: <pre><code>  - ID: 1, Nombre com\u00fan: Aloe Vera, Nombre cient\u00edfico: Aloe barbadensis miller, Frecuencia de riego: 7 d\u00edas, Altura: 0.6 metros\n  - ID: 2, Nombre com\u00fan: Lavanda, Nombre cient\u00edfico: Lavandula angustifolia, Frecuencia de riego: 3 d\u00edas, Altura: 1.0 metros\n  - ID: 3, Nombre com\u00fan: Helecho de Boston, Nombre cient\u00edfico: Nephrolepis exaltata, Frecuencia de riego: 5 d\u00edas, Altura: 0.9 metros\n  - ID: 4, Nombre com\u00fan: Bamb\u00fa de la suerte, Nombre cient\u00edfico: Dracaena sanderiana, Frecuencia de riego: 4 d\u00edas, Altura: 1.5 metros\n  - ID: 5, Nombre com\u00fan: Girasol, Nombre cient\u00edfico: Helianthus annuus, Frecuencia de riego: 2 d\u00edas, Altura: 3.0 metros\n\nInformaci\u00f3n guardada en: datos_ini\\mis_plantas2.xml\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_intercambio/#43-json-javascript-object-notation","title":"4.3. JSON (JavaScript Object Notation)","text":"<p>Son ficheros ligeros, f\u00e1ciles de leer y con una estructura de pares clave-valor y listas. Ideales para APIs REST, ficheros de configuraci\u00f3n y bases de datos NoSQL (como MongoDB). Se maneja con librer\u00edas como Jackson &amp; Gson (Java) o kotlinx.serialization (la que utilizaremos en Kotlin).</p>"},{"location":"unidades/ud02/ficheros_intercambio/#metodos-de-kotlinxserialization","title":"M\u00e9todos de kotlinx.serialization","text":"M\u00e9todo / Ejemplo Descripci\u00f3n <code>Json.encodeToString(objeto)</code> <code>Json.encodeToString(persona)</code> <code>Json.encodeToString(serializer, obj)</code> <code>Json.encodeToString(Persona.serializer(), persona)</code> <code>Json.decodeFromString(json)</code> <code>Json.decodeFromString&lt;Persona&gt;(json)</code> <code>Json.decodeFromString(serializer, s)</code> <code>Json.decodeFromString(Persona.serializer(), json)</code> <code>Json.encodeToJsonElement(objeto)</code> <code>val elem = Json.encodeToJsonElement(persona)</code> <code>Json.decodeFromJsonElement(elem)</code> <code>val persona = Json.decodeFromJsonElement&lt;Persona&gt;(elem)</code> <code>Json.parseToJsonElement(string)</code> <code>val elem = Json</code>"},{"location":"unidades/ud02/ficheros_intercambio/#ejemplo-de-lectura-y-escritura-de-ficheros-json","title":"Ejemplo de lectura y escritura de ficheros JSON:","text":"<p>Partimos de un fichero llamado <code>mis_plantas.json</code> con la informaci\u00f3n siguiente: <pre><code>[\n  {\n    \"id_planta\": 1,\n    \"nombre_comun\": \"Aloe Vera\",\n    \"nombre_cientifico\": \"Aloe barbadensis miller\",\n    \"frecuencia_riego\": 7,\n    \"altura_maxima\": 0.6\n  },\n  {\n    \"id_planta\": 2,\n    \"nombre_comun\": \"Lavanda\",\n    \"nombre_cientifico\": \"Lavandula angustifolia\",\n    \"frecuencia_riego\": 3,\n    \"altura_maxima\": 1.0\n  },\n  {\n    \"id_planta\": 3,\n    \"nombre_comun\": \"Helecho de Boston\",\n    \"nombre_cientifico\": \"Nephrolepis exaltata\",\n    \"frecuencia_riego\": 5,\n    \"altura_maxima\": 0.9\n  },\n  {\n    \"id_planta\": 4,\n    \"nombre_comun\": \"Bamb\u00fa de la suerte\",\n    \"nombre_cientifico\": \"Dracaena sanderiana\",\n    \"frecuencia_riego\": 4,\n    \"altura_maxima\": 1.5\n  },\n  {\n    \"id_planta\": 5,\n    \"nombre_comun\": \"Girasol\",\n    \"nombre_cientifico\": \"Helianthus annuus\",\n    \"frecuencia_riego\": 2,\n    \"altura_maxima\": 3.0\n  }\n]\n</code></pre> Utilizaremos la librer\u00eda kotlinx.serialization. Por tanto habr\u00e1 que indicarlo en el fichero <code>build.gradle.kts</code> a\u00f1adiendo las siguientes l\u00edneas:</p> <ul> <li>En <code>plugins</code>: <pre><code>kotlin(\"plugin.serialization\") version \"1.9.0\"\n</code></pre></li> <li>En <code>dependencies</code>: <pre><code>implementation (\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0\")\n</code></pre></li> </ul> <p>Llamaremos a <code>Json.encodeToString()</code> para serializar una instancia de esta clase y a <code>Json.decodeFromString()</code> para deserializarla.</p> <p><pre><code>import java.nio.file.Files\nimport java.nio.file.Path\nimport java.io.File\n// Clases de la librer\u00eda oficial de Kotlin para la serializaci\u00f3n/deserializaci\u00f3n.\nimport kotlinx.serialization.*\nimport kotlinx.serialization.json.*\n//Usamos una 'data class' para representar la estructura de una planta e indicamos que es serializable\n@Serializable\ndata class Planta(val id_planta: Int, val nombre_comun: String, val nombre_cientifico: String, val frecuencia_riego: Int, val altura_maxima: Double)\nfun main() {\n    val entradaJSON = Path.of(\"datos_ini/mis_plantas.json\")\n    val salidaJSON = Path.of(\"datos_ini/mis_plantas2.json\")\n    val datos: List&lt;Planta&gt;\n    datos = leerDatosInicialesJSON(entradaJSON)\n    for (dato in datos) {\n        println (\"  - ID: ${dato.id_planta}, Nombre com\u00fan: ${dato.nombre_comun}, Nombre cient\u00edfico: ${dato.nombre_cientifico}, Frecuencia de riego: ${dato.frecuencia_riego} d\u00edas, Altura: ${dato.altura_maxima} metros\")\n    }\n    escribirDatosJSON(salidaJSON, datos)\n}\nfun leerDatosInicialesJSON(ruta: Path): List&lt;Planta&gt; {\n    var plantas: List&lt;Planta&gt; = emptyList()\n    val jsonString = Files.readString(ruta)\n    /* A `Json.decodeFromString` le pasamos el String con el JSON.\n    Con `&lt;List&lt;Planta&gt;&gt;`, le indicamos que debe interpretarlo como\n    una lista de objetos de tipo planta\".\n    La librer\u00eda usar\u00e1 la anotaci\u00f3n @Serializable de la clase Planta para saber c\u00f3mo mapear los campos del JSON (\"id_planta\", \"nombre_comun\", etc.)\n    a las propiedades del objeto. */\n    plantas = Json.decodeFromString&lt;List&lt;Planta&gt;&gt;(jsonString)\n    return plantas\n}\nfun escribirDatosJSON(ruta: Path,plantas: List&lt;Planta&gt;) {\n    try {\n        /* La librer\u00eda `kotlinx.serialization`\n        toma la lista de objetos `Planta` (`List&lt;Planta&gt;`) y la convierte en una\n        \u00fanica cadena de texto con formato JSON.\n        `prettyPrint` formatea el JSON para que sea legible. */\n        val json = Json { prettyPrint = true }.encodeToString(plantas)\n        // Con `Files.writeString` escribimos el String JSON en el fichero de salida\n        Files.writeString(ruta, json)\n        println (\"\\nInformaci\u00f3n guardada en: $ruta\")\n    } catch (e: Exception) {\n        println (\"Error: ${e.message}\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior, comprueba que la salida es la siguiente, que se ha creado el fichero <code>mis_plantas2.json</code> y que su contenido es correcto: <pre><code>  - ID: 1, Nombre com\u00fan: Aloe Vera, Nombre cient\u00edfico: Aloe barbadensis miller, Frecuencia de riego: 7 d\u00edas, Altura: 0.6 metros\n  - ID: 2, Nombre com\u00fan: Lavanda, Nombre cient\u00edfico: Lavandula angustifolia, Frecuencia de riego: 3 d\u00edas, Altura: 1.0 metros\n  - ID: 3, Nombre com\u00fan: Helecho de Boston, Nombre cient\u00edfico: Nephrolepis exaltata, Frecuencia de riego: 5 d\u00edas, Altura: 0.9 metros\n  - ID: 4, Nombre com\u00fan: Bamb\u00fa de la suerte, Nombre cient\u00edfico: Dracaena sanderiana, Frecuencia de riego: 4 d\u00edas, Altura: 1.5 metros\n  - ID: 5, Nombre com\u00fan: Girasol, Nombre cient\u00edfico: Helianthus annuus, Frecuencia de riego: 2 d\u00edas, Altura: 3.0 metros\n\nInformaci\u00f3n guardada en: datos_ini\\mis_plantas2.json\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_intercambio/#44-conversiones-entre-ficheros","title":"4.4. Conversiones entre ficheros","text":"<p>Una vez vistas las caracter\u00edsticas de los ficheros de intercambio de informaci\u00f3n m\u00e1s comunes podemos llegar a la conclusi\u00f3n que en programaci\u00f3n y gesti\u00f3n de datos, no todos los formatos sirven igual para todos los casos. Convertir entre CSV, JSON y XML permite aprovechar las ventajas de cada uno.</p> <p>El patr\u00f3n para convertir datos de un formato a otro es casi siempre el mismo. En lugar de intentar una conversi\u00f3n directa, utilizamos nuestras clases de Kotlin (<code>data class</code>) como un paso intermedio universal:</p> <p>Formato Origen \u2192 Objetos Kotlin en Memoria \u2192 Formato Destino</p> <p>\ud83d\udd0d Realiza algunas conversiones entre ficheros CSV, JSON y XML para practicar la lectura / escritura y la serializaci\u00f3n / deserializaci\u00f3n. Puedes reutilizar el c\u00f3digo de los ejemplos.</p>"},{"location":"unidades/ud02/ficheros_intercambio/#practica-3-creacion-y-lectura-de-un-fichero-de-datos","title":"\ud83c\udfaf Pr\u00e1ctica 3: Creaci\u00f3n y lectura de un fichero de datos","text":"<p>Realiza lo siguiente:</p> <ul> <li>Dise\u00f1a tu data class: Define la <code>data class</code> de Kotlin que represente un \u00fanico elemento de tu colecci\u00f3n de datos. Debe tener un ID \u00fanico de tipo <code>Int</code>, un nombre de tipo <code>String</code> y, al menos, otros dos campos (al menos uno de tipo <code>Double</code>).</li> <li>Crea tu fichero de datos: (.csv, .json o .xml) con al menos 5 registros de tu colecci\u00f3n dentro de la carpeta <code>datos_ini</code>.</li> <li>A\u00f1ade dependencias necesarias: A\u00f1ade las librer\u00edas necesarias para leer tu fichero y serializar / deserializar datos en <code>build.gradle.kts</code>.</li> <li>Crea la funci\u00f3n de lectura: La funci\u00f3n debe leer el fichero de texto y devolver una lista de objetos <code>leerDatosIniciales(): List&lt;DataClass&gt;</code>.</li> <li>Verifica que funciona: Imprime por consola la informaci\u00f3n le\u00edda.</li> <li>Aspectos T\u00e9cnicos Obligatorios:<ul> <li>Se debe incluir un manejo b\u00e1sico de errores (ej: comprobar si el fichero existe antes de leerlo, try-catch para conversiones num\u00e9ricas, etc.).</li> </ul> </li> </ul>"},{"location":"unidades/ud02/ficheros_intercambio/#entrega-parcial","title":"\ud83d\udcc1 Entrega parcial","text":"<p>Entrega el c\u00f3digo fuente del proyecto comprimido en un fichero <code>.zip</code> para que el profesor te d\u00e9 sugerencias de mejora (el programa entregado deber\u00e1 ejecutarse, si da error de ejecuci\u00f3n, no se podr\u00e1 revisar).</p>"},{"location":"unidades/ud02/ficheros_texto/","title":"Ficheros de texto","text":""},{"location":"unidades/ud02/ficheros_texto/#3-ficheros-de-texto","title":"3. Ficheros de texto","text":"<p>Los ficheros de texto son legibles directamente por humanos y son una buena opci\u00f3n para guardar informaci\u00f3n despu\u00e9s de cerrar el programa. A continuaci\u00f3n se muestran algunas clases y m\u00e9todos para leer y escribir informaci\u00f3n en ellos:</p>"},{"location":"unidades/ud02/ficheros_texto/#metodos-de-ficheros-de-texto","title":"M\u00e9todos de Ficheros de Texto","text":"M\u00e9todo Descripci\u00f3n <code>Files.readAllLines(path)</code> devuelve <code>List&lt;String&gt;</code> Leer ficheros. <code>Files.exists(path)</code> Verificar existencia. <code>split()</code>, <code>trim()</code>, <code>toIntOrNull()</code> Procesar texto. <code>Files.write(path, lines)</code> Escribe una lista de l\u00edneas (<code>List&lt;String&gt;</code>) a un fichero. <code>StandardOpenOption.READ</code> Abrir un fichero en modo lectura. <code>StandardOpenOption.WRITE</code> Abrir un fichero en modo escritura. <code>StandardOpenOption.APPEND</code> Agrega contenido al final del fichero sin borrar lo anterior. <code>StandardOpenOption.CREATE</code> Si no existe, lo crea. <code>StandardOpenOption.TRUNCATE_EXISTING</code> Si existe, borra lo anterior. <code>Files.newBufferedReader(Path)</code>, <code>Files.newBufferedWriter(Path)</code> M\u00e1s eficiente para ficheros grandes. <code>Files.readString(Path)</code> (Java 11+), <code>Files.writeString(Path, String)</code> Lectura/escritura completa como bloque. <p>Dentro de los ficheros de texto existen ficheros de texto plano (sin ning\u00fan tipo de estructura) y ficheros de texto en los que la informaci\u00f3n est\u00e1 estructurada.</p>"},{"location":"unidades/ud02/ficheros_texto/#ejemplo-escritura-y-lectura-en-fichero-de-texto-plano-txt","title":"Ejemplo - Escritura y lectura en fichero de texto plano .txt:","text":"<p><pre><code>import java.nio.file.Files\nimport java.nio.file.Paths\nimport java.nio.charset.StandardCharsets\nfun main() {\n    //Escritura en fichero de texto\n    //writeString\n    val texto = \"Hola, mundo desde Kotlin\"\n    Files.writeString(Paths.get(\"documentos/saludo.txt\"), texto)\n    //write\n    val ruta = Paths.get(\"documentos/texto.txt\")\n    val lineasParaGuardar = listOf(\n        \"Primera l\u00ednea\",\n        \"Segunda l\u00ednea\",\n        \"\u00a1Hola desde Kotlin!\"\n    )\n    Files.write(ruta, lineasParaGuardar, StandardCharsets.UTF_8)\n    println (\"Fichero de texto escrito.\")\n    //newBuffered\n    Files.newBufferedWriter(Paths.get(\"documentos/log.txt\")).use { writer -&gt;\n        writer.write(\"Log iniciado...\\n\")\n        writer.write(\"Proceso completado.\\n\")\n    }\n    //Lectura del fichero de texto\n    //readAllLines\n    val lineasLeidas = Files.readAllLines(ruta)\n    println (\"Contenido le\u00eddo con readAllLines:\")\n    for (lineas in lineasLeidas) {\n        println (lineas)\n    }\n    //readString\n    val contenido = Files.readString(ruta)\n    println (\"Contenido le\u00eddo con readString:\")\n    println (contenido)\n    //newBufferedReader\n    Files.newBufferedReader(ruta).use { reader -&gt;\n        println (\"Contenido le\u00eddo con newBufferedReader:\")\n        reader.lineSequence().forEach { println (it) }\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Fichero de texto escrito.\nContenido le\u00eddo con readAllLines:\nPrimera l\u00ednea\nSegunda l\u00ednea\n\u00a1Hola desde Kotlin!\nContenido le\u00eddo con readString:\nPrimera l\u00ednea\nSegunda l\u00ednea\n\u00a1Hola desde Kotlin!\n\nContenido le\u00eddo con newBufferedReader:\nPrimera l\u00ednea\nSegunda l\u00ednea\n\u00a1Hola desde Kotlin!\n</code></pre></p>"},{"location":"unidades/ud02/introduccion/","title":"UD2 - Persistencia en ficheros","text":""},{"location":"unidades/ud02/introduccion/#resumen","title":"Resumen","text":"<p>En este documento se recogen los contenidos referentes al RA1 (desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en ficheros identificando el campo de aplicaci\u00f3n de los mismos y utilizando clases espec\u00edficas).</p>"},{"location":"unidades/ud02/introduccion/#guia-de-uso","title":"Gu\u00eda de uso","text":"<p>Estos apuntes est\u00e1n dise\u00f1ados para que aprendas haciendo. A lo largo de la unidad, no solo veremos la teor\u00eda, sino que la aplicaremos directamente para construir, paso a paso, una aplicaci\u00f3n completa de gesti\u00f3n de datos. El tema de la aplicaci\u00f3n lo eliges t\u00fa, pero los pasos que daremos ser\u00e1n los mismos para todos. Siguiendo la unidad no solo habr\u00e1s aprendido los conceptos, sino que tendr\u00e1s una aplicaci\u00f3n completa y funcional creada por ti.</p> <p>Intercaladas con la teor\u00eda y con los ejemplos encontrar\u00e1s tres tipos de cajas:</p> <ul> <li>\ud83d\udd0d Ejecutar y analizar: \"Estas cajas son para analizar y comprender en detalle el ejemplo de c\u00f3digo proporcionado. Tu tarea es ejecutar ese c\u00f3digo, observar la salida y asegurarte de entender c\u00f3mo y por qu\u00e9 funciona.\"</li> <li>\ud83c\udfaf Pr\u00e1ctica para aplicar y construir: \"Estas cajas son pr\u00e1cticas que debes realizar t\u00fa. Es el momento de ponerte a programar y aplicar lo que acabas de aprender. Son los objetivos que debes completar para avanzar. Cada una de estas pr\u00e1cticas es un bloque que debes programar para ir avanzando en tu proyecto final. En cada pr\u00e1ctica ampliar\u00e1s lo de las anteriores.\"</li> <li>\ud83d\udcc1 Entrega: \"Estas cajas son entregas de tu trabajo. Las entregas pueden ser parciales (el profesor te dar\u00e1 sugerencias de mejora) o finales (el profesor calificar\u00e1 el trabajo que has realizado). No todas las pr\u00e1cticas llevan asociada una entrega.\"</li> </ul>"},{"location":"unidades/ud02/introduccion/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Un fichero o archivo es una unidad de almacenamiento de datos en un sistema inform\u00e1tico. Es un conjunto de informaci\u00f3n (secuencia de bytes) organizada y almacenada en un dispositivo de almacenamiento (disco duro, memoria USB o un servidor en la nube). Los datos guardados en ficheros persisten m\u00e1s all\u00e1 de la ejecuci\u00f3n de la aplicaci\u00f3n que los trata. La utilizaci\u00f3n de ficheros es una alternativa sencilla y eficiente a las bases de datos.</p>"},{"location":"unidades/ud02/introduccion/#caracteristicas-de-un-fichero","title":"Caracter\u00edsticas de un fichero:","text":"<ul> <li>Nombre: Cada fichero tiene un nombre \u00fanico dentro de su directorio.</li> <li>Extensi\u00f3n: Indica su tipo (.txt para texto, .jpg para im\u00e1genes, etc).</li> <li>Ubicaci\u00f3n: Directorios (carpetas) dentro del sistema de ficheros.</li> <li>Contenido: Texto, im\u00e1genes, v\u00eddeos, c\u00f3digo fuente, bases de datos, etc.</li> <li>Permisos de acceso: Se pueden configurar para permitir o restringir la lectura, escritura o ejecuci\u00f3n a determinados usuarios o programas.</li> </ul>"},{"location":"unidades/ud02/introduccion/#tipos-de-ficheros","title":"Tipos de ficheros:","text":"<ul> <li>De texto: Formato legible por humanos (.txt, .csv, .json, .xml).</li> <li>Binarios: Formato no legible directamente (.exe, .jpg, .mp3, .dat).</li> <li>De c\u00f3digo fuente: Contienen instrucciones escritas en lenguajes de programaci\u00f3n (.java, .kt, .py).</li> <li>De configuraci\u00f3n: Almacenan par\u00e1metros de configuraci\u00f3n de programas (.ini, .conf, .properties, .json).</li> <li>De bases de datos: Se utilizan para almacenar grandes vol\u00famenes de datos estructurados (.db, .sql).</li> <li>Historial: de eventos o errores en un sistema (.log).</li> </ul>"},{"location":"unidades/ud02/introduccion/#api-para-manejo-de-ficheros","title":"API para manejo de ficheros:","text":"<p>Java.nio (New IO) es una API disponible desde la versi\u00f3n 7 de Java que permite mejorar el rendimiento, as\u00ed como simplificar el manejo de muchas operaciones. Funciona a trav\u00e9s de interfaces y clases para que la m\u00e1quina virtual Java tenga acceso a ficheros, atributos de ficheros y sistemas de ficheros. En los siguientes apartados veremos c\u00f3mo trabajar con ella.</p>"},{"location":"unidades/ud02/introduccion/#formas-de-acceso","title":"Formas de acceso:","text":"<p>El acceso a ficheros es una tarea fundamental en la programaci\u00f3n, ya que permite leer y escribir datos persistentes. Hemos visto que hay diferentes tipos de ficheros, seg\u00fan sus caracter\u00edsticas y necesidades existen dos formas principales de acceder a un fichero (secuencial y aleatorio):</p> <ul> <li> <p>Acceso secuencial: Los datos se procesan en orden, desde el principio hasta el final del fichero. Es el m\u00e1s com\u00fan y sencillo. Se usa cuando se desea leer todo el contenido o recorrer registro por registro. Por ejemplo lectura de un fichero de texto l\u00ednea por l\u00ednea, o de un fichero binario estructurado registro a registro.</p> </li> <li> <p>Acceso aleatorio: Permite saltar a una posici\u00f3n concreta del fichero sin necesidad de leer lo anterior. Es \u00fatil cuando los registros tienen un tama\u00f1o fijo y se necesita eficiencia (por ejemplo, ir directamente al registro 100). Requiere t\u00e9cnicas m\u00e1s avanzadas como el uso de <code>FileChannel</code>, <code>SeekableByteChannel</code> o <code>RandomAccessFile</code>.</p> </li> </ul> <p>A lo largo de esta unidad se explicar\u00e1n algunas funciones de manejo de ficheros que requieren librer\u00edas externas (dependencias). Utilizaremos Gradle para descargarlas autom\u00e1ticamente en nuestros proyectos.</p> <p>Para crear un proyecto Kotlin con Gradle en IntelliJ haremos clic en New Project, indicamos la informaci\u00f3n de la siguiente imagen, haremos clic en el bot\u00f3n Create y esperaremos a que IntelliJ prepare el proyecto.</p> <p>A medida que necesitemos utilizar dependencias en nuestro proyecto, las iremos a\u00f1adiendo al fichero build.gradle.kts en la secci\u00f3n de dependencias. Si despu\u00e9s de a\u00f1adirlas no se descargan autom\u00e1ticamente, abrir la ventana Gradle (lateral derecho de IntelliJ) y hacer clic en el bot\u00f3n de actualizar.</p>"},{"location":"unidades/ud02/introduccion/#practica-1-proyecto-kotlin-con-gradle","title":"\ud83c\udfaf Pr\u00e1ctica 1: Proyecto Kotlin con Gradle","text":"<p>En esta pr\u00e1ctica has de crear un proyecto que ir\u00e1s ampliando a lo largo de toda la unidad. Realiza lo siguiente:</p> <ul> <li>Piensa en una aplicaci\u00f3n de gesti\u00f3n orientada al sector que prefieras y busca un nombre original (ser\u00e1 el nombre de tu proyecto).</li> <li>Crea un nuevo proyecto con Gradle y comprobar que se ejecuta correctamente (puedes utilizar el c\u00f3digo de ejemplo de IntelliJ).</li> </ul>"}]}
{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Acceso a datos DAM","text":""},{"location":"#descripcion","title":"Descripci\u00f3n","text":"<p>Material del m\u00f3dulo de Acceso a Datos de 2\u00ba de DAM del IES CAMP DE MORVEDRE.</p> Fecha Versi\u00f3n Descripci\u00f3n 19/09/2025 1.0.0 Adaptaci\u00f3n del material. Estructura web con mkdocs."},{"location":"#enlaces-de-interes","title":"Enlaces de inter\u00e9s","text":"<ul> <li>Todo el material est\u00e1 disponible en el repositorio del m\u00f3dulo</li> </ul>"},{"location":"#autoria-y-revision","title":"Autor\u00eda y revisi\u00f3n","text":"<p>Obra realizada por Bego\u00f1a Paterna basado en materiales de Alicia Salvador. Adaptado, revisado y ampliado por Jos\u00e9 Manuel Abad L\u00f3pez. </p> <p>Publicada bajo licencia Creative Commons Atribuci\u00f3n/Reconocimiento-CompartirIgual 4.0 Internacional</p>"},{"location":"#repositorio-y-contacto","title":"Repositorio y contacto","text":"<p>https://jmabadlopez.github.io jmabadlopez@edu.gva.es</p>"},{"location":"ejercicios/ud01/ejemplo/","title":"Ejemplo","text":"Fecha Versi\u00f3n Descripci\u00f3n 14/09/2021 1.0.0 Versi\u00f3n inicial. 16/09/2021 1.0.1 Correcci\u00f3n de numeraci\u00f3n de ejercicios. 11/09/2025 1.0.5 Adaptaci\u00f3n mkdocs."},{"location":"ejercicios/ud01/ejemplo/#ejercicios-unidad-1-introduccion-a-la-programacion","title":"Ejercicios Unidad 1 - Introducci\u00f3n a la programaci\u00f3n","text":""},{"location":"ejercicios/ud01/ejemplo/#1-programas-y-algoritmos","title":"1. Programas y Algoritmos.","text":"<p>Responde a las siguientes preguntas con palabras tus (no t\u00e9cnicas).</p> <ol> <li>\u00bfQu\u00e9 hace un programa?</li> <li>\u00bfQu\u00e9 son los datos?</li> <li>\u00bfC\u00f3mo se comunica un programa con el usuario?</li> <li>Un programa y un algoritmo es lo mismo?</li> <li>\u00bfQu\u00e9 es un compilador?</li> <li>\u00bfPor qu\u00e9 Java es portable?</li> <li>Di 3 caracter\u00edsticas deseables de un algoritmo.</li> <li>Di verdadero o falso:<ul> <li>Una aplicaci\u00f3n inform\u00e1tica puede estar formada por muchos programas.</li> <li>Un algoritmo puede representarse de varias maneras.</li> <li>Un algoritmo puede programarse en diversos lenguajes de programaci\u00f3n.</li> <li>C es un lenguaje portable.</li> <li>Necesitamos un compilador de C para cada plataforma.</li> </ul> </li> </ol>"},{"location":"ejercicios/ud01/ejemplo/#2-la-informacion","title":"2. La informaci\u00f3n","text":"<p>Responde a las siguientes preguntas con tus palabras (no hace falta que sean t\u00e9cnicas).</p> <ol> <li>\u00bfC\u00f3mo se guarda la informaci\u00f3n en los ordenadores? \u00bfPor qu\u00e9 tiene que estar organizada?</li> <li>\u00bfCu\u00e1l es la diferencia entre una variable y una constante?</li> <li>Di las tres caracter\u00edsticas de una variable.</li> <li>\u00bfQu\u00e9 problemas puede dar la falta de precisi\u00f3n?</li> <li> <p>Di cu\u00e1les de los siguientes identificadores son correctos o incorrectos:</p> <ul> <li><code>letra</code></li> <li><code>Letra</code></li> <li><code>123precio</code></li> <li><code>__variable__</code></li> <li><code>precio123</code></li> <li><code>cantidad_envases</code></li> <li><code>__.__</code></li> <li><code>Canto total</code></li> <li><code>CHAR</code></li> <li><code>char</code></li> </ul> </li> <li> <p>Piensa 2 ejemplos de datos compuestos y con qu\u00e9 tipos simples pueden estar formados.</p> </li> </ol>"},{"location":"ejercicios/ud01/ejemplo/#3-expresiones","title":"3. Expresiones","text":"<ol> <li> <p>Calcula el valor de cada expresi\u00f3n si es v\u00e1lida. Si no es v\u00e1lida, indica el motivo.</p> <ul> <li><code>10 * 3 + 5 * 2</code></li> <li><code>15 % 4</code></li> <li><code>2 + 7 / 3</code></li> <li><code>4 +\" precio \"</code></li> <li><code>(5 + 2) &lt;8</code></li> <li><code>4&gt; = 4</code></li> <li><code>true OR false</code></li> <li><code>5 OR (2 &lt;3)</code></li> <li><code>(6&gt; = 2) OR (3 &lt;= 5)</code></li> <li><code>NOT (NOT (NOT (4 &lt;10)))</code></li> <li><code>4 + false</code></li> <li><code>4 + 2 * 4 / 2</code></li> <li><code>((5 &lt;0) AND (6&gt; = 7)) OR (45% 5 &lt;= 0</code></li> <li><code>((10 - 4)&gt; 0) OR true</code></li> <li><code>((10-4) &lt;0) OR true</code></li> </ul> </li> <li> <p>Dados los siguientes valores de las variables <code>X = 1, Y = 4, Z = 10</code> y la constante<code>PI = 3.14</code>, eval\u00faa las expresiones siguientes. Importante fijarse en el resultado del tipo de retorno.</p> <ul> <li><code>2 * X + 0.5 * Y - 1/5 * Z</code></li> <li><code>((PI * X ^ 2)&gt; Y) OR ((2 * PI * X) &lt;= Z)</code></li> <li><code>\" Hola, mundo! \" == \"Hola,\" + \"mundo!\"</code></li> <li><code>'a' == 'A'</code></li> </ul> </li> <li> <p>A partir de las siguientes constantes <code>gran = falso; redondo = cierto; suave = falso</code> indica cu\u00e1l ser\u00e1 el valor despu\u00e9s de cada una de las siguientes asignaciones:</p> <ul> <li><code>grande y redondo y suave</code></li> <li><code>grande o redondo o suave</code></li> <li><code>grande y redondo o suave</code></li> <li><code>grande o redondo y suave</code></li> <li><code>grande y (redondo o suave)</code></li> <li><code>(grande o redondo) y suave</code></li> </ul> </li> <li> <p>Indica con par\u00e9ntesis el orden en que el ordenador ejecutar\u00eda las diferentes operaciones.</p> <ul> <li><code>x + y + z</code></li> <li><code>x * y + z</code></li> <li><code>x + y * z</code></li> <li><code>x - y * z</code></li> <li><code>x + y / z</code></li> <li><code>x * y / z</code></li> <li><code>x / y / z</code></li> <li><code>x / y * y + x% y</code></li> <li><code>x / y + z + x</code></li> </ul> </li> <li> <p>Siendo a, b, c y d variables num\u00e9ricas, escribe la expresi\u00f3n l\u00f3gica correspondiente a:</p> <ul> <li>Los valores de b y c son ambos superiores al valor de d:</li> <li>a, b y c son id\u00e9nticos</li> <li>a, b y c son id\u00e9nticos pero diferentes de d</li> <li>b est\u00e1 comprendido, estrictamente, entre los valores de a y c</li> <li>b est\u00e1 comprendido, estrictamente, entre los valores de a y c, y el valor de a es menor que el valor de c</li> <li>Hay, al menos, dos valores id\u00e9nticos entre a, b y c</li> </ul> </li> <li> <p>Observa la siguiente secuencia de instrucciones. Responde a las cuestiones:</p> </li> </ol> <pre><code>a=5;\nb=7;\nc=2;\na=a+b+c;\nb=c/2;\na=a/b+a^c;\nESCRIBIR(a);\n</code></pre> <ul> <li>\u00bfQu\u00e9 valor contiene a despu\u00e9s de la cuarta instrucci\u00f3n?</li> <li>\u00bfQu\u00e9 valor contiene b despu\u00e9s de la quinta instrucci\u00f3n?</li> <li>\u00bfQu\u00e9 valor contiene a despu\u00e9s de la sexta instrucci\u00f3n?</li> <li>\u00bfQu\u00e9 valor imprime la \u00faltima instrucci\u00f3n?   </li> </ul>"},{"location":"unidades/ud01/ud01/","title":"UD 1 Introducci\u00f3n a Kotlin","text":"<p>En este documento se realiza una introducci\u00f3n al lenguaje de programaci\u00f3n Kotlin utilizando el IDE IntelliJ en su versi\u00f3n Community.</p> <p></p>"},{"location":"unidades/ud01/ud01/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>En el m\u00f3dulo de Programaci\u00f3n, de 1\u00ba de DAM, hemos trabajado con Java, un lenguaje orientado a objetos y ampliamente utilizado en el desarrollo de aplicaciones empresariales. Aprendimos conceptos como estructuras de control, clases, objetos y herencia.</p> <p>Este curso, en el m\u00f3dulo de Acceso a Datos, vamos a continuar aplicando estos mismos conceptos utilizando Kotlin, un lenguaje moderno, conciso y seguro. Kotlin funciona sobre la m\u00e1quina virtual de Java (JVM), fue desarrollado por JetBrains (los creadores de IntelliJ IDEA) y es 100% interoperable con Java.</p> <p>Los principales usos de Kotlin son: aplicaciones Android, aplicaciones de escritorio (con Swing, JavaFX o Compose Desktop), backends web (con frameworks como Ktor o Spring) y desarrollo multiplataforma (Kotlin Multiplatform).</p>"},{"location":"unidades/ud01/ud01/#2-instalacion-de-intellij-community","title":"2. Instalaci\u00f3n de IntelliJ Community","text":"<p>En este curso utilizaremos el IDE IntelliJ en su versi\u00f3n Community. Para instalarlo podemos descargarlo del enlace oficial https://www.jetbrains.com/idea/download/. Dependiendo de nuestro sistema operativo, escogeremos el instalador que mejor se ajuste a nuestras necesidades.</p> <p></p>"},{"location":"unidades/ud01/ud01/#3-proyectos","title":"3. Proyectos","text":"<p>Antes de empezar hay que tener en cuenta c\u00f3mo vamos a organizar nuestros proyectos. Cada uno de nosotros podemos tener una metodolog\u00eda de trabajo distinta (puede que unos prefieran crear un proyecto para cada ejercicio, otros un proyecto por unidad, etc). En los ejemplos de estos materiales, se ha creado una carpeta de trabajo llamada <code>kot</code> en la que se guardar\u00e1n los distintos proyectos.</p> <p>Tambi\u00e9n podemos configurar el entorno de trabajo a nuestro gusto entrando al men\u00fa de ajustes. Para ello hacemos clic en el icono de la rueda dentada que hay en la esquina inferior izquierda de la pantalla principal del programa.</p> <p>Una vez realizadas estas aclaraciones, ya podemos trabajar con proyectos. A continuaci\u00f3n veremos algunos aspectos importantes.</p>"},{"location":"unidades/ud01/ud01/#31-creacion-del-proyecto","title":"3.1. Creaci\u00f3n del proyecto","text":"<p>Para crear nuestro proyecto debemos realizar los siguientes pasos: - Abrir la aplicaci\u00f3n y, en la ventana inicial, hacer clic en el icono New Project.</p> <p></p> <ul> <li>Indicar los par\u00e1metros del proyecto:<ul> <li>Marcar la opci\u00f3n Kotlin en la columna izquierda.</li> <li>Indicar el nombre del proyecto y su ubicaci\u00f3n.</li> <li>Asegurarnos que aparece seleccionado el sistema IntelliJ.</li> </ul> </li> </ul> <p></p> <ul> <li>Por \u00faltimo, hacer clic en el bot\u00f3n Create.</li> </ul> <p>Con estos pasos ya tendremos nuestro nuevo proyecto (<code>prueba1</code>) que aparecer\u00e1 en una nueva ventana con un peque\u00f1o programa de ejemplo.</p> <p></p>"},{"location":"unidades/ud01/ud01/#32-ejecucion-de-la-aplicacion","title":"3.2. Ejecuci\u00f3n de la aplicaci\u00f3n","text":"<p>Para ejecutarla hay que hacer clic en el icono Play. El proyecto debe tener, al menos, un m\u00e9todo <code>main</code>, Kotlin utiliza la palabra reservada <code>fun</code> para declararlo. El resultado de la ejecuci\u00f3n aparecer\u00e1 por consola (en la parte inferior de la pantalla).</p> <p></p>"},{"location":"unidades/ud01/ud01/#33-estructura-de-carpetas","title":"3.3. Estructura de carpetas","text":"<p>Como vimos en Java, al crear un nuevo proyecto se crea una estructura de carpetas y los archivos fuentes deben estar en la carpeta src. En este caso, Kotlin funciona exactamente igual. Para crear una nueva clase o archivo hay que hacer clic con el bot\u00f3n derecho del rat\u00f3n sobre carpeta src, luego hacer clic en New, luego clic en Kotlin File/Class y por \u00faltimo indicar el nombre.</p> <p></p>"},{"location":"unidades/ud01/ud01/#34-compartir-proyectos","title":"3.4. Compartir proyectos","text":"<p>Por \u00faltimo vamos a recordar c\u00f3mo compartir proyectos (para entregar en una tarea de clase, para hacer copia de seguridad, etc). Se realiza desde fuera de IntelliJ utilizando el explorador de archivos del sistema operativo. Para ello hay que localizar la carpeta correspondiente al proyecto y comprimirla.</p> <p></p>"},{"location":"unidades/ud01/ud01/#4-variables","title":"4. Variables","text":"<p>Una variable es un espacio en memoria que guarda un dato (un n\u00famero, un texto, etc). En Kotlin existen dos formas principales de declarar variables:</p>"},{"location":"unidades/ud01/ud01/#41-val-inmutable-no-se-puede-cambiar","title":"4.1. val \u2013 Inmutable (no se puede cambiar)","text":"<p>Es como una constante: una vez que le das un valor, no puedes cambiarlo.</p> <pre><code>val pi = 3.1416\nprintln (\"El valor de PI es $pi\")\n</code></pre>"},{"location":"unidades/ud01/ud01/#42-var-mutable-se-puede-cambiar","title":"4.2. var \u2013 Mutable (se puede cambiar)","text":"<p>Es una variable normal: puedes cambiar su valor m\u00e1s adelante.</p> <pre><code>var contador = 0\ncontador += 1\nprintln (\"Contador: $contador\")  // Salida: Contador: 1\n</code></pre>"},{"location":"unidades/ud01/ud01/#43-tipos-de-datos","title":"4.3. Tipos de datos","text":"<p>En Kotlin no es necesario declarar el tipo de una variable (aunque puede hacerse). A continuaci\u00f3n se detallan los tipos m\u00e1s comunes:</p> Tipo Descripci\u00f3n Ejemplo Byte Entero peque\u00f1o (8 bits) <code>val a: Byte = 1</code> Short Entero corto (16 bits) <code>val b: Short = 100</code> Int Entero est\u00e1ndar (32 bits) <code>val c: Int = 1000</code> Long Entero largo (64 bits). Se debe a\u00f1adir la L al final del n\u00famero <code>val d: Long = 100000L</code> Float Decimal de precisi\u00f3n simple (32 bits). Se debe a\u00f1adir la f al final del n\u00famero <code>val e: Float = 1.5f</code> Double Decimal de precisi\u00f3n doble (64 bits). Es el tipo por defecto <code>val f: Double = 3.14</code> Char Caracter individual <code>val letra: Char = 'A'</code> String Texto (Tambi\u00e9n se puede acceder a los caracteres individualmente) <code>val saludo: String = \"Hola Mundo\"</code><code>val letra = saludo[0]  // 'H'</code> Boolean Verdadero o falso <code>val esMayor = true</code> <p>A continuaci\u00f3n se muestran los operadores aritm\u00e9ticos:</p> Operador Nombre Ejemplo Resultado + Suma <code>5 + 3</code> 8 - Resta <code>10 - 4</code> 6 * Multiplicaci\u00f3n <code>6 * 2</code> 12 / Divisi\u00f3n (entera o real) <code>9 / 3</code> 3 % M\u00f3dulo (resto de una divisi\u00f3n) <code>10 % 3</code> 1 <p>En Kotlin, una divisi\u00f3n entre enteros da como resultado un n\u00famero entero: <code>val resultado = 7 / 2</code> // Resultado: 3</p> <p>Para obtener decimales, al menos uno debe ser tipo Double o Float: <code>val resultado = 7.0 / 2</code> // Resultado: 3.5</p> <p>En Kotlin, Por defecto, las variables no pueden ser nulas, el siguiente c\u00f3digo dar\u00eda un error de compilaci\u00f3n ya que nombre no puede ser null:</p> <pre><code>var nombre: String = \"Pol\"\nnombre = null // Esto dar\u00e1 un error de compilaci\u00f3n\n</code></pre> <p>Para permitir valores nulos, se usa el operador <code>?</code>. Ahora el ejemplo ya es correcto:</p> <pre><code>var nombre: String? = \"Pol\"\nnombre = null\n</code></pre> <p>Kotlin tiene unos operadores para evitar errores cuando se trabaja con variables que pueden ser null. A continuaci\u00f3n se describen estos operadores:</p> Operador Nombre Descripci\u00f3n <code>?.</code> Llamada segura Ejecuta el m\u00e9todo solo si la variable no es null <code>?:</code> Elvis operator Devuelve un valor por defecto si la variable es null. <code>!!</code> Not null assertion Fuerza el acceso a la variable. Si es null, lanza <code>NullPointerException</code>. <p>Ejemplo 1 - Llamada segura (<code>?.</code>):</p> <pre><code>var nombre: String? = null\nprintln (nombre?.length)   // No lanza error, devuelve: null\nnombre = \"Pol\"\nprintln (nombre?.length)   // Devuelve 3\n</code></pre> <p>Ejemplo 2 - Valor por defecto (<code>?:</code>):</p> <pre><code>var nombre: String? = null\nvar mostrar = nombre ?: \"Desconocido\"\nprintln (mostrar)   // Si nombre es null imprime: Desconocido\nnombre = \"Pol\"\nmostrar = nombre ?: \"Desconocido\"\nprintln (mostrar)   // Si nombre es \"Pol\" imprime: Pol\n</code></pre> <p>Ejemplo 3 - Acceso forzado (<code>!!</code>):</p> <pre><code>val nombre: String? = null\nprintln (nombre!!.length)   // Lanza NullPointerException\n</code></pre> <p>Ejemplo 4 - Uso con if:</p> <pre><code>if (nombre != null) {\n    println (\"Hola, ${nombre.uppercase()}\")\n} else {\n    println (\"Nombre no disponible\")\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#5-entrada-y-salida-estandar","title":"5. Entrada y salida est\u00e1ndar","text":"<p>Cuando queremos mostrar informaci\u00f3n al usuario o pedirle informaci\u00f3n utilizamos la consola. Las funciones m\u00e1s comunes para comunicarnos con \u00e9l son:</p> Funci\u00f3n Descripci\u00f3n Ejemplo Salida <code>print()</code> Imprime texto en pantalla, sin salto de l\u00ednea al final. <code>print(\"Hola \")</code><code>print(\"mundo\")</code> <code>Hola mundo</code> <code>println()</code> Imprime texto en pantalla y a\u00f1ade un salto de l\u00ednea al final. <code>println(\"Hola\")</code><code>println(\"mundo\")</code> <code>Hola</code><code>mundo</code> <code>readLine()</code> Lee una l\u00ednea de texto que el usuario escribe por teclado. <p><code>readLine()</code> devuelve un valor de tipo String (que puede ser nulo). Hay que convertirlo si se espera otro tipo de dato (<code>toInt()</code>, <code>toDouble()</code>, etc.). Antes de la conversi\u00f3n hay que asegurarse de que no est\u00e1 vac\u00edo.</p> <pre><code>fun main() {\n    print (\"Introduce tu edad: \")\n   val entrada =  readLine()\n   if (entrada != null &amp;&amp; entrada.isNotBlank()) {\n       val edad = entrada.toInt()\n        println (\"Tendr\u00e1s ${edad + 1} a\u00f1os el pr\u00f3ximo a\u00f1o\")\n   } else {\n        println (\"Edad no v\u00e1lida\")\n   }\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#6-condicionales","title":"6. Condicionales","text":"<p>Las condiciones en Kotlin se tratan de manera muy parecida a Java y para ello se utilizan los operadores relacionales.</p> Operador Significado Ejemplo Resultado <code>==</code> Igual a <code>5 == 5</code> <code>true</code> <code>!=</code> Distinto de <code>5 != 3</code> <code>true</code> <code>&gt;</code> Mayor que <code>10 &gt; 7</code> <code>true</code> <code>&lt;</code> Menor que <code>3 &lt; 8</code> <code>true</code> <code>&gt;=</code> Mayor o igual que <code>6 &gt;= 6</code> <code>true</code> <code>&lt;=</code> Menor o igual que <code>4 &lt;= 9</code> <code>true</code> <p>Estos operadores pueden combinarse con los operadores l\u00f3gicos siguientes:</p> Operador Nombre Ejemplo Resultado <code>&amp;&amp;</code> AND <code>(edad &gt; 18 &amp;&amp; tieneID)</code> <code>true</code> si ambas son <code>true</code> <code>||</code> OR <code>(edad &gt; 18 || tieneID)</code> <code>true</code> si alguna es <code>true</code> <code>!</code> NOT <code>!esActivo</code> Invierte el valor: <code>true</code> \u2192 <code>false</code> <p>Ejemplo 1 - condicional simple:</p> <pre><code>val edad = 18\nif (edad &gt;= 18) {\n    println (\"Eres mayor de edad\")\n}\n</code></pre> <p>Ejemplo 2 - if-else:</p> <pre><code>val numero = 5\nif (numero % 2 == 0) {\n    println (\"Es par\")\n} else {\n    println (\"Es impar\")\n}\n</code></pre> <p>Ejemplo 3 - if anidados:</p> <pre><code>val edad = 22\nval tieneID = true\nval esEmpleado = false\nval tienePaseEspecial = true\nif (edad &gt;= 18 &amp;&amp; tieneID) {\n    println (\"Edad y documento verificados\")\n   if (esEmpleado || tienePaseEspecial) {\n        println (\"Acceso permitido a la zona restringida\")\n   } else {\n        println (\"Acceso denegado: no eres empleado o no tienes pase\")\n   }\n} else {\n    println (\"Acceso denegado: no cumples con edad o documentaci\u00f3n\")\n}\n</code></pre> <p>Ejemplo 4 - como expresi\u00f3n (devuelve un valor):</p> <pre><code>val max = if (a &gt; b) a else b\n</code></pre> <p>Ejemplo 5 - when (como switch):</p> <pre><code>val dia = 3\nval nombreDia = when (dia) {\n   1 -&gt; \"Lunes\"\n   2 -&gt; \"Martes\"\n   3 -&gt; \"Mi\u00e9rcoles\"\n   else -&gt; \"D\u00eda inv\u00e1lido\"\n}\n</code></pre> <p>Ejemplo 6 - when con condiciones:</p> <pre><code>val nota = 85\nval resultado = when {\n   nota &gt;= 90 -&gt; \"Excelente\"\n   nota &gt;= 70 -&gt; \"Aprobado\"\n   else -&gt; \"Reprobado\"\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#7-repeticiones","title":"7. Repeticiones","text":"<p>A continuaci\u00f3n se ven las estructuras repetitivas <code>while</code>, <code>do-while</code>, <code>for</code> y <code>repeat</code>.</p>"},{"location":"unidades/ud01/ud01/#71-while","title":"7.1. while","text":"<p>Repite mientras la condici\u00f3n sea verdadera. Se eval\u00faa la condici\u00f3n antes de entrar al ciclo. Si la condici\u00f3n es falsa desde el principio, el bloque no se ejecuta.</p> <pre><code>var contador = 1\nwhile (contador &lt;= 5) {\n    println (\"Contador: $contador\")\n   contador++\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#72-do-while","title":"7.2. do-while","text":"<p>Hace la acci\u00f3n al menos una vez, luego verifica la condici\u00f3n. Se ejecuta primero el bloque de c\u00f3digo, y luego se eval\u00faa la condici\u00f3n.</p> <pre><code>var contador = 1\ndo {\n    println (\"Contador: $contador\")\n   contador++\n} while (contador &lt;= 5)\n</code></pre>"},{"location":"unidades/ud01/ud01/#73-for","title":"7.3. for","text":"<p>Recorre un rango, lista o secuencia. Se usa cuando sabemos cu\u00e1ntas veces queremos repetir algo.</p> <pre><code>for (i in 1..5) {\n    println (\"Iteraci\u00f3n: $i\")\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#74-repeat","title":"7.4. repeat","text":"<p>Repite una acci\u00f3n N veces (sin necesidad de un rango ni una colecci\u00f3n).</p> <pre><code>repeat(3) {\n    println(\"Hola\")\n}\n</code></pre> Estructura \u00bfCu\u00e1ndo usarla? \u00bfEval\u00faa primero? \u00bfSe ejecuta al menos una vez? <code>while</code> Cuando no sabemos cu\u00e1ntas veces, pero depende de una condici\u00f3n. S\u00ed No <code>do-while</code> Cuando queremos que se ejecute al menos una vez. No S\u00ed <code>for</code> Cuando sabemos cu\u00e1ntas veces o queremos recorrer algo. S\u00ed S\u00ed <code>repeat</code> Cuando queremos repetir algo un n\u00famero fijo de veces. - -"},{"location":"unidades/ud01/ud01/#8-estructuras-de-datos","title":"8. Estructuras de datos","text":"<p>Las estructuras de datos son formas de organizar, almacenar y manipular informaci\u00f3n de manera eficiente. Las principales estructuras de datos en Kotlin son:</p>"},{"location":"unidades/ud01/ud01/#81-array","title":"8.1. Array","text":"<p>Colecci\u00f3n ordenada de tama\u00f1o fijo. Todos sus elementos son del mismo tipo. A cada elemento se accede mediante un \u00edndice. Se utiliza cuando se tiene un n\u00famero fijo de elementos del mismo tipo.</p> <ul> <li>1. Crear un array vac\u00edo con un tama\u00f1o fijo y luego llenarlo:</li> </ul> <pre><code>val calificaciones = IntArray(5)  // Los 5 enteros con valor 0\ncalificaciones[0] = 95\n</code></pre> <ul> <li>2. Asignar los valores directamente:</li> </ul> <pre><code>val edades = intArrayOf(15, 18, 20)\n</code></pre> <ul> <li>3. Utilizar <code>arrayOf</code>:</li> </ul> <pre><code>val numeros = arrayOf(10, 20, 30, 40, 50)\n</code></pre> <p>No existe una clase concreta para manejar el tipo String y por tanto se utiliza el m\u00e9todo gen\u00e9rico <code>arrayOf</code> visto en el ejemplo anterior:</p> <pre><code>val nombres = arrayOf(\"Pol\", \"Eli\", \"Ade\")\nprintln(nombres[1])  // Salida: Eli\n</code></pre> <ul> <li>Acceder a los elementos de un array:</li> </ul> <pre><code>println(numeros[0])  // Salida: 10\nprintln(numeros[3])  // Salida: 40\n</code></pre> <ul> <li>Cambiar un valor del array:</li> </ul> <pre><code>numeros[2] = 99\nprintln(numeros[2])  // Salida: 99\n</code></pre> <ul> <li>Tama\u00f1o del array:</li> </ul> <pre><code>println(\"Tama\u00f1o del array: ${numeros.size}\")\n</code></pre> <ul> <li>2 formas de recorrer un array con un for:</li> </ul> <pre><code>for (numero in numeros) {\n    println(numero)\n}\nfor (i in 0..numeros.size - 1) {\n    println(numeros[i])\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#82-list-lista","title":"8.2. List (lista)","text":"<p>Colecci\u00f3n ordenada que permite elementos duplicados. Puede ser inmutable (<code>List</code>) o mutable (<code>MutableList</code>). Se utiliza cuando se quiere mantener un orden y permitir elementos repetidos.</p> <pre><code>val nombres = listOf(\"Pol\", \"Eli\", \"Ade\") // No modificable\nprintln(nombres) // [Pol, Eli, Ade]\n\nval nombresMutable = mutableListOf(\"Pol\", \"Eli\")\nnombresMutable.add(\"Ade\")  // A\u00f1adir un elemento al final\nnombresMutable.add(1, \"Fer\") // A\u00f1adir en una posici\u00f3n espec\u00edfica\nnombresMutable[1] = \"Sam\"   // Cambiar el valor en una posici\u00f3n espec\u00edfica\nnombresMutable.remove(\"Sam\") // Eliminar por valor\nnombresMutable.removeAt(0)  // Eliminar por \u00edndice\nnombresMutable.clear()      // Eliminar todos los elementos\n</code></pre>"},{"location":"unidades/ud01/ud01/#83-set-conjunto","title":"8.3. Set (conjunto)","text":"<p>Colecci\u00f3n sin duplicados, sin orden garantizado. Puede ser inmutable (<code>Set</code>) o mutable (<code>MutableSet</code>). Se utiliza cuando no se quieren duplicados y el orden no importa.</p> <pre><code>val set = setOf(\"Rojo\", \"Verde\", \"Rojo\")  // \"Rojo\" solo se guarda una vez\nprintln(set) // Imprime: [Rojo, Verde]\n\nval frutas = mutableSetOf(\"Manzana\", \"Banana\", \"Uva\")\nfrutas.add(\"Naranja\") // Agregar un elemento\nprintln(frutas)\nfrutas.add(\"Banana\") // Intentar agregar un duplicado\nprintln(frutas)\nfrutas.remove(\"Uva\") // Eliminar un elemento\nprintln(frutas)\n\nif (\"Banana\" in frutas) {\n    println(\"S\u00ed hay Banana\")\n}\nfor (fruta in frutas) {\n    println(\"Fruta: $fruta\")\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#84-map-diccionario-o-mapa","title":"8.4. Map (diccionario o mapa)","text":"<p>Colecci\u00f3n de pares clave \u2192 valor. Cada clave es \u00fanica; \u00fatil para representar relaciones. Puede ser inmutable (<code>Map</code>) o mutable (<code>MutableMap</code>). Se utiliza cuando se quiere asociar claves con valores.</p> <pre><code>val edades = mapOf(\"Pol\" to 18, \"Ade\" to 20)\nprintln(edades[\"Ade\"])  // Imprime 20\n\nval datos = mutableMapOf&lt;String, Int&gt;()\ndatos[\"Pol\"] = 25\ndatos[\"Eli\"] = 20\nprintln(\"Pol:\" + datos[\"Pol\"])\nprintln(\"Eli:\" + datos[\"Eli\"])\n</code></pre> Estructura Ordenada Claves \u00fanicas Permite duplicados Modificable <code>Array</code> S\u00ed No S\u00ed (depende) <code>List</code> S\u00ed No S\u00ed si es mutable <code>Set</code> No S\u00ed No si es mutable <code>Map</code> No S\u00ed (en claves) en valores si es mutable"},{"location":"unidades/ud01/ud01/#9-funciones","title":"9. Funciones","text":"<p>Son bloques de c\u00f3digo que realizan tareas espec\u00edficas (m\u00e9todos en Java) y sirven para organizar, reutilizar y evitar repetir el mismo c\u00f3digo varias veces.</p> <ul> <li>Ejemplo de funci\u00f3n sin par\u00e1metros ni retorno:</li> </ul> <pre><code>fun saludar() {\n    println(\"\u00a1Hola, bienvenidos a la clase!\")\n}\nsaludar()\n</code></pre> <ul> <li>Ejemplo de funci\u00f3n con par\u00e1metros:</li> </ul> <pre><code>fun saludarEstudiante(nombre: String) {\n    println(\"Hola, $nombre\")\n}\nsaludarEstudiante(\"Pol\")\n</code></pre> <ul> <li>Ejemplo de funci\u00f3n que devuelve un valor (n\u00famero entero):</li> </ul> <pre><code>fun sumar(a: Int, b: Int): Int {\n   return a + b\n}\nvar suma = sumar(2, 3)\n</code></pre> <ul> <li>Ejemplo de funci\u00f3n con forma simplificada:</li> </ul> <pre><code>fun multiplicar(a: Int, b: Int) = a * b\nvar multi = multiplicar(3,5)\n</code></pre> <ul> <li>Ejemplo de funci\u00f3n con par\u00e1metro con valor por defecto:</li> </ul> <pre><code>fun saludar(nombre: String = \"Pol\") {\n    println(\"Hola, $nombre\")\n}\nsaludar()\nsaludar(\"Eli\")\n</code></pre> <ul> <li>Ejemplo de funci\u00f3n con par\u00e1metros combinados (algunos con valores por defecto):</li> </ul> <pre><code>fun mostrarMensaje(mensaje: String, veces: Int = 1) {\n    repeat(veces) {\n        println(mensaje)\n    }\n}\nmostrarMensaje(\"\u00a1Hola!\")\nmostrarMensaje(\"\u00a1Hola!\", 3)\n</code></pre> <ul> <li>Ejemplo de llamada con argumentos nombrados:</li> </ul> <pre><code>fun mostrarMensaje(mensaje: String, veces: Int = 1) {\n    repeat(veces) {\n        println(mensaje)\n    }\n}\nmostrarMensaje(\"Hola a todos\", 2)\nmostrarMensaje(mensaje = \"Hola a todos\", veces = 2)\nmostrarMensaje(veces = 2, mensaje = \"Hola a todos\")\n</code></pre> <ul> <li>Ejemplo de funci\u00f3n con un array de enteros como par\u00e1metro y retorno:</li> </ul> <pre><code>fun duplicarValores(numeros: Array&lt;Int&gt;): Array&lt;Int&gt; {\n   val resultado = Array(numeros.size) { i -&gt; numeros[i] * 2 }\n    return resultado\n}\nval original = arrayOf(1, 2, 3)\nval duplicados = duplicarValores(original)\nprintln(\"Original: ${original.joinToString()}\")\nprintln(\"Duplicados: ${duplicados.joinToString()}\")\n</code></pre> <ul> <li>Ejemplo de funci\u00f3n con un array de Strings como par\u00e1metro y retorno:</li> </ul> <pre><code>fun agregarSigno(nombres: Array&lt;String&gt;): Array&lt;String&gt; {\n   return Array(nombres.size) { i -&gt; \"${nombres[i]}!\" }\n}\nval nombres = arrayOf(\"Pol\", \"Eli\", \"Ade\")\nval nombresConSigno = agregarSigno(nombres)\nprintln(\"Original: ${nombres.joinToString()}\")\nprintln(\"Con signo: ${nombresConSigno.joinToString()}\")\n</code></pre>"},{"location":"unidades/ud01/ud01/#91-funciones-locales","title":"9.1. Funciones locales","text":"<p>Una funci\u00f3n local es una funci\u00f3n que se define dentro de otra funci\u00f3n. Solo puede ser usada dentro de esa funci\u00f3n de forma interna.</p> <pre><code>fun procesarTexto(texto: String) {\n   fun limpiar(cadena: String): String {\n       return cadena.trim().lowercase()\n   }\n   val resultado = limpiar(texto)\n    println(\"Texto procesado: $resultado\")\n}\nprocesarTexto(\"   Hola Mundo   \")\n</code></pre>"},{"location":"unidades/ud01/ud01/#92-funciones-con-cantidad-variable-de-argumentos","title":"9.2. Funciones con cantidad variable de argumentos","text":"<p>Un par\u00e1metro de una funci\u00f3n puede recibir una cantidad variable de argumentos (0 o m\u00e1s), como si fuera un \"array flexible\" pero sin necesidad de pasarlos como un array. Para ello se utiliza la palabra clave <code>vararg</code>.</p> <pre><code>fun saludarVarios(vararg nombres: String) {\n   for (nombre in nombres) {\n        println(\"Hola, $nombre\")\n   }\n}\nsaludarVarios(\"Pol\", \"Eli\")\n</code></pre> <ul> <li>Ejemplo de combinar vararg con otros par\u00e1metros:</li> </ul> <pre><code>fun mostrarNumeros(titulo: String, vararg numeros: Int) {\n    println(titulo)\n   for (n in numeros) {\n        println(n)\n   }\n}\nmostrarNumeros(\"Lista de n\u00fameros:\", 3, 5, 7)\n</code></pre> <ul> <li>Ejemplo pasando valores desde un array:</li> </ul> <pre><code>fun imprimirNumeros(vararg numeros: Int) {\n   for (n in numeros) {\n        println(n)\n   }\n}\nval lista = intArrayOf(1, 2, 3, 4)\nimprimirNumeros(*lista)\n\nval extra = intArrayOf(4, 5)\nimprimirNumeros(1, 2, 3, *extra, 6)\n</code></pre>"},{"location":"unidades/ud01/ud01/#93-funciones-de-orden-superior","title":"9.3. Funciones de orden superior","text":"<p>Una funci\u00f3n de orden superior es una funci\u00f3n que trabaja con funciones como si fueran datos.</p> <ul> <li>Ejemplo 1:</li> </ul> <pre><code>fun opera(a: Int, b: Int, op: (Int, Int) -&gt; Int): Int {\n   return op(a, b)\n}\nval suma = opera(3, 4) { x, y -&gt; x + y }\nval resta = opera(10, 5) { x, y -&gt; x - y }\nprintln(\"Suma: $suma\")\nprintln(\"Resta: $resta\")\n</code></pre> <ul> <li>Ejemplo 2:</li> </ul> <pre><code>fun crearMultiplicador(factor: Int): (Int) -&gt; Int {\n   return { numero -&gt; numero * factor }\n}\nval porTres = crearMultiplicador(3)\nprintln(porTres(5))\n</code></pre>"},{"location":"unidades/ud01/ud01/#10-poo","title":"10. POO","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es una forma de escribir programas donde todo gira en torno a objetos. Un objeto es una combinaci\u00f3n de datos (como caracter\u00edsticas o propiedades) y m\u00e9todos (acciones que puede hacer). En POO, usamos clases para crear estos objetos.</p>"},{"location":"unidades/ud01/ud01/#ejemplo-1-constructor-primario","title":"Ejemplo 1 - Constructor primario:","text":"<pre><code>class Estudiante(val nombre: String, val edad: Int) {\n   // M\u00e9todo para imprimir los datos del estudiante\n    fun imprimirDatos() {\n        println(\"Nombre: $nombre, Edad: $edad\")\n   }\n    // M\u00e9todo para verificar si es menor de edad\n    fun esMenorDeEdad(): Boolean {\n       return edad &lt; 18\n   }\n}\nfun main() {\n   val estudiante1 = Estudiante(\"Pol\", 16)\n   estudiante1.imprimirDatos()\n    println(\"\u00bfEs menor de edad? ${estudiante1.esMenorDeEdad()}\\n\")\n   val estudiante2 = Estudiante(\"Eli\", 20)\n   estudiante2.imprimirDatos()\n    println(\"\u00bfEs menor de edad? ${estudiante2.esMenorDeEdad()}\")\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#ejemplo-2-propiedades-dentro-del-cuerpo","title":"Ejemplo 2 - Propiedades dentro del cuerpo:","text":"<pre><code>class Estudiante() {\n   var nombre: String = \"\"\n   var edad: Int = 0\n   fun imprimirDatos() {\n        println(\"Nombre: $nombre, Edad: $edad\")\n   }\n   fun esMenorDeEdad(): Boolean {\n       return edad &lt; 18\n   }\n}\nfun main() {\n   val estudiante1 = Estudiante()\n   estudiante1.nombre = \"Pol\"\n   estudiante1.edad = 16\n   estudiante1.imprimirDatos()\n    println(\"\u00bfEs menor de edad? ${estudiante1.esMenorDeEdad()}\\n\")\n   val estudiante2 = Estudiante()\n   estudiante2.nombre = \"Eli\"\n   estudiante2.edad = 20\n   estudiante2.imprimirDatos()\n    println(\"\u00bfEs menor de edad? ${estudiante2.esMenorDeEdad()}\")\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#ejemplo-3-constructor-secundario","title":"Ejemplo 3 - constructor secundario:","text":"<pre><code>class Estudiante {\n   var nombre: String = \"\"\n   var edad: Int = 0\n    // Constructor secundario\n    constructor(nombre: String, edad: Int) {\n       this.nombre = nombre\n       this.edad = edad\n   }\n    fun imprimirDatos() {\n        println(\"Nombre: $nombre, Edad: $edad\")\n   }\n    fun esMenorDeEdad(): Boolean {\n       return edad &lt; 18\n   }\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#101-constructor-primario-secundario","title":"10.1. Constructor primario + secundario","text":"<pre><code>class Estudiante(val nom: String, val edad: Int, val direccion: String) {\n    // Constructor secundario que asigna una direcci\u00f3n vac\u00eda\n    constructor(nom: String, edad: Int) : this(nom, edad, \"Sin direcci\u00f3n\")\n   fun imprimirDatos() {\n        println(\"Nombre: $nom, Edad: $edad, Direcci\u00f3n: $direccion\")\n   }\n   fun esMenorDeEdad(): Boolean {\n       return edad &lt; 18\n   }\n}\nfun main() {\n   val estudiante1 = Estudiante(\"Pol\", 16, \"Calle Mayor\")\n   estudiante1.imprimirDatos()\n    println(\"\u00bfEs menor de edad? ${estudiante1.esMenorDeEdad()}\\n\")\n   val estudiante2 = Estudiante(\"Eli\", 20)\n   estudiante2.imprimirDatos()\n    println(\"\u00bfEs menor de edad? ${estudiante2.esMenorDeEdad()}\")\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#102-getters-y-setters","title":"10.2. getters y setters","text":"<p><code>get</code> y <code>set</code> son mecanismos para acceder y modificar propiedades, y forman parte del encapsulamiento y control de acceso. En Kotlin todas las propiedades (<code>var</code>) tienen autom\u00e1ticamente un getter y un setter.</p> <ul> <li>Ejemplo 1 - Getters y Setters autom\u00e1ticos:</li> </ul> <pre><code>class Estudiante {\n   var nombre: String = \"Sin nombre\"\n}\nfun main() {\n   val estudiante = Estudiante()\n   estudiante.nombre = \"Pol\"     // setter autom\u00e1tico\n   println(estudiante.nombre)    // getter autom\u00e1tico. Salida: Pol\n}\n</code></pre> <ul> <li>Ejemplo 2 - Personalizar el getter y el setter:</li> </ul> <pre><code>class Producto {\n   var nombre: String = \"Sin nombre\"\n    var precio: Double = 0.0\n       get() {\n            println(\"Obteniendo precio...\")\n           return field\n        }\n       set(value) {\n            println(\"Asignando precio: $value\")\n            field = if (value &gt;= 0) value else 0.0\n        }\n}\nfun main() {\n   val producto = Producto()\n    producto.precio = 120.0\n   println(\"Precio actual: ${producto.precio}\")\n    producto.precio = -50.0\n   println(\"Precio actual: ${producto.precio}\")\n    producto.nombre = \"Teclado inal\u00e1mbrico\"\n    println(\"Nombre del producto: ${producto.nombre}\")\n}\n</code></pre> <ul> <li>Ejemplo 3 - Propiedad de solo lectura (<code>val</code> con <code>get</code> personalizado):</li> </ul> <pre><code>class Circulo(val radio: Double) {\n   val area: Double\n       get() = Math.PI * radio * radio\n}\nfun main() {\n   val c = Circulo(5.0)\n    println(\"\u00c1rea del c\u00edrculo: ${c.area}\")\n}\n</code></pre> <ul> <li>Ejemplo 4 - Setter privado:</li> </ul> <pre><code>class Usuario(val nombre: String) {\n   var edad: Int = 0\n       private set   // Solo se puede modificar dentro de la clase\n    fun cumplea\u00f1os() {\n       edad++\n   }\n}\nfun main() {\n   val usuario = Usuario(\"Pol\")\n   usuario.cumplea\u00f1os()\n    println(\"Edad: ${usuario.edad}\")\n   // usuario.edad = 30  // Esto dar\u00eda un error de compilaci\u00f3n\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#103-relacion-entre-clases","title":"10.3. Relaci\u00f3n entre clases","text":"<p>Normalmente en una aplicaci\u00f3n necesitaremos programar varias clases que se relacionar\u00e1n unas con otras.</p> <pre><code>class Curso(val nombre: String, val duracionSemanas: Int) {\n   fun infoCurso(): String {\n       return \"Curso: $nombre, Duraci\u00f3n: $duracionSemanas semanas\"\n   }\n}\nclass Estudiante(\n   val nombre: String,\n   val edad: Int,\n   val direccion: String,\n   val curso: Curso\n) {\n   constructor() : this(\"Sin nombre\", 0, \"Sin direc\", Curso(\"Ninguno\", 0))\n   fun imprimirDatos() {\n        println(\"Nombre: $nombre\")\n        println(\"Edad: $edad\")\n        println(\"Direcci\u00f3n: $direccion\")\n       imprimirEstadoEdad()\n        println(curso.infoCurso())\n    }\n   fun esMenorDeEdad(): Boolean {\n       return edad &lt; 18\n   }\n   fun imprimirEstadoEdad() {\n       val estado = if (esMenorDeEdad()) \"es menor\" else \"mayor de edad\"\n        println(\"Estado: Es $estado.\")\n   }\n}\nfun main() {\n   val cursoKotlin = Curso(\"Kotlin B\u00e1sico\", 6)\n   val cursoJava = Curso(\"Java Intermedio\", 8)\n   val estudiante1 = Estudiante(\"Pol\", 16, \"C. Mayor\", cursoKotlin)\n   val estudiante2 = Estudiante(\"Eli\", 20, \"Enmedio 89\", cursoJava)\n   estudiante1.imprimirDatos()\n    println()\n   estudiante2.imprimirDatos()\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#104-acceso-a-metodos-y-propiedades","title":"10.4. Acceso a m\u00e9todos y propiedades","text":"<p>En Kotlin todo es p\u00fablico por defecto. Para indicar qui\u00e9n puede ver o usar una clase, propiedad o m\u00e9todo desde fuera de la clase se utilizan los modificadores de acceso.</p> <pre><code>class CuentaBancaria(val titular: String) {\n   private var saldo: Double = 0.0\n    fun depositar(cantidad: Double) {\n       saldo += cantidad\n   }\n   fun mostrarSaldo() {\n        println(\"Saldo actual: $saldo\")\n   }\n}\nfun main() {\n   val cuenta = CuentaBancaria(\"Mar\u00eda\")\n   cuenta.depositar(100.0)\n   cuenta.mostrarSaldo()\n   // cuenta.saldo = 1000.0  // ERROR: saldo es private\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#105-herencia","title":"10.5. Herencia","text":"<p>La Herencia es un mecanismo por el cual una clase (subclase) puede heredar propiedades y m\u00e9todos de otra clase (superclase). Por seguridad, en Kotlin: - Las clases no se pueden heredar a menos que se marquen con <code>open</code>. - Los m\u00e9todos tambi\u00e9n deben ser <code>open</code> para poder sobrescribirse.</p> <pre><code>open class Animal(val nombre: String) {\n   open fun hacerSonido() {\n        println(\"$nombre hace un sonido gen\u00e9rico\")\n   }\n}\nclass Perro(nombre: String) : Animal(nombre) {\n   override fun hacerSonido() {\n       super.hacerSonido()\n       println(\"$nombre dice: \u00a1Guau!\")\n   }\n}\nclass Gato(nombre: String) : Animal(nombre) {\n   override fun hacerSonido() {\n       super.hacerSonido()\n       println(\"$nombre dice: \u00a1Miau!\")\n   }\n}\nfun main() {\n   val animal = Animal(\"Criatura\")\n   val perro = Perro(\"Firulais\")\n   val gato = Gato(\"Misu\")\n   animal.hacerSonido()\n    println(\"----\")\n   perro.hacerSonido()\n    println(\"----\")\n   gato.hacerSonido()\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#106-arrays-y-arraylists-de-objetos","title":"10.6. Arrays y ArrayLists de objetos","text":"<ul> <li>Ejemplo 1 - Array de objetos:</li> </ul> <pre><code>fun main() {\n    val animales: Array&lt;Animal&gt; = arrayOf(\n       Perro(\"Rocky\"),\n       Gato(\"Luna\"),\n       Perro(\"Max\"),\n       Animal(\"Criatura misteriosa\"),\n       Gato(\"Nina\")\n   )\n    for (animal in animales) {\n       animal.hacerSonido()\n   }\n}\n</code></pre> <ul> <li>Ejemplo 2 - ArrayList de objetos:</li> </ul> <pre><code>fun main() {\n    val animales = mutableListOf&lt;Animal&gt;(\n       Perro(\"Rocky\"),\n       Gato(\"Luna\"),\n       Perro(\"Max\"),\n       Animal(\"Criatura misteriosa\"),\n       Gato(\"Nina\")\n   )\n    println(\"Todos los animales hacen sonido:\")\n   for (animal in animales) {\n       animal.hacerSonido()\n   }\n    println(\"\\nSolo los perros:\")\n   val soloPerros = animales.filterIsInstance&lt;Perro&gt;()\n   for (perro in soloPerros) {\n       perro.hacerSonido()\n   }\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#107-funciones-de-extension","title":"10.7. Funciones de extensi\u00f3n","text":"<p>Las funciones de extensi\u00f3n permiten a\u00f1adir nuevas funciones a clases existentes sin tener que modificarlas ni heredar de ellas.</p> <ul> <li>Ejemplo 1 - Funci\u00f3n de extensi\u00f3n para la clase String:</li> </ul> <pre><code>fun String.saludar(): String {\n   return \"Hola, $this\"\n}\nfun main() {\n   val nombre = \"Pol\"\n    println(nombre.saludar())\n}\n</code></pre> <ul> <li>Ejemplo 2 - Funci\u00f3n de extensi\u00f3n para una clase personalizada:</li> </ul> <pre><code>open class Animal(val nombre: String) {\n   open fun hacerSonido() {\n        println(\"$nombre hace un sonido gen\u00e9rico\")\n   }\n}\nfun Animal.nombreEnMayusculas(): String {\n   return nombre.uppercase()\n}\nfun main() {\n   val gato = Animal(\"Misu\")\n    println(gato.nombreEnMayusculas())\n}\n</code></pre> <ul> <li>Ejemplo 3 - Funci\u00f3n de extensi\u00f3n con l\u00f3gica adicional:</li> </ul> <pre><code>fun Int.esPar(): Boolean {\n   return this % 2 == 0\n}\nfun main() {\n   val numero = 4\n   if (numero.esPar()) {\n        println(\"$numero es par\")\n   } else {\n        println(\"$numero es impar\")\n   }\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#108-data-class","title":"10.8. data class","text":"<p>Una <code>data class</code> es una clase pensada para almacenar datos sin necesidad de implementar funcionalidades.</p> <pre><code>data class Libro(val titulo: String, val autor: String, val any: Int)\nfun main() {\n    val libro1 = Libro(\"1984\", \"George Orwell\", 1949)\n   val libro2 = Libro(\"Cien a\u00f1os de soledad\", \"Gabriel Garc\u00eda M\u00e1rquez\", 1967)\n   val libro3 = Libro(\"Fahrenheit 451\", \"Ray Bradbury\", 1953)\n   val libro4 = Libro(\"Orgullo y prejuicio\", \"Jane Austen\", 1813)\n    val biblioteca = listOf(libro1, libro2, libro3, libro4)\n    println(\"Biblioteca completa:\")\n   for (libro in biblioteca) {\n        println(libro.titulo + \" - \" + libro.autor + \" (\" + libro.any + \")\")\n   }\n    println(\"\\nLibros ordenados por a\u00f1o (de menor a mayor):\")\n   val ordenados = biblioteca.sortedBy { it.any }\n    for (libro in ordenados) {\n        println(libro.titulo + \" -&gt; \" + libro.any)\n   }\n    println(\"\\nCopiar un libro y cambiar su a\u00f1o:\")\n   val libroModificado = libro1.copy(any = 2025)\n    println(\"Original: \" + libro1.toString())\n    println(\"Modificado: \" + libroModificado.toString())\n    println(\"\\n\u00bfSon iguales los objetos? \" + (libro1 == libroModificado))\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#109-sobrecarga-de-operadores","title":"10.9. Sobrecarga de operadores","text":"<p>La sobrecarga de operadores permite definir o personalizar el comportamiento de los operadores (+, -, *, ==, etc.) al aplicarse sobre instancias de nuestras propias clases.</p> <ul> <li>Ejemplo 1 - Clase Punto con operador + sobrecargado:</li> </ul> <pre><code>data class Punto(val x: Int, val y: Int) {\n    operator fun plus(otro: Punto): Punto {\n       return Punto(this.x + otro.x, this.y + otro.y)\n   }\n}\nfun main() {\n   val p1 = Punto(2, 3)\n   val p2 = Punto(4, 1)\n   val resultado = p1 + p2\n   println(resultado)\n}\n</code></pre> <ul> <li>Ejemplo 2 - Comparar dos animales por nombre:</li> </ul> <pre><code>class Animal(val nombre: String) {\n    override operator fun equals(other: Any?): Boolean {\n       return other is Animal &amp;&amp; this.nombre == other.nombre\n   }\n}\nfun main() {\n   val a1 = Animal(\"Luna\")\n   val a2 = Animal(\"Luna\")\n   val a3 = Animal(\"Max\")\n    println(a1 == a2)\n   println(a1 == a3)\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#11-funciones-lambda","title":"11. Funciones lambda","text":"<p>Las funciones lambda son funciones definidas sin un nombre, utilizadas para operaciones simples y r\u00e1pidas, mejorando la legibilidad del c\u00f3digo y el rendimiento.</p> <ul> <li>Ejemplo b\u00e1sico:</li> </ul> <pre><code>val saludar = { nombre: String -&gt; println(\"Hola, $nombre\") }\nsaludar(\"Pol\")\n</code></pre> <ul> <li>Ejemplo sin par\u00e1metros:</li> </ul> <pre><code>val decirHola = { println(\"Hola\") }\ndecirHola()\n</code></pre> <ul> <li>Ejemplo con m\u00faltiples par\u00e1metros:</li> </ul> <pre><code>val sumar = { a: Int, b: Int -&gt; a + b }\nprintln(sumar(3, 4))\n</code></pre> <ul> <li>Ejemplo 1 - forEach con IntArray:</li> </ul> <pre><code>val numeros = intArrayOf(1, 2, 3, 4, 5)\nnumeros.forEach { println(it) }\n</code></pre> <ul> <li>Ejemplo 2 - map para transformar:</li> </ul> <pre><code>val numeros = intArrayOf(1, 2, 3)\nval dobles = numeros.map { it * 2 }\nprintln(dobles)\n</code></pre> <ul> <li>Ejemplo 3 - map + toIntArray():</li> </ul> <pre><code>val numeros = intArrayOf(1, 2, 3)\nval doblesArray = numeros.map { it * 2 }.toIntArray()\n</code></pre> <ul> <li>Ejemplo 4 - filter para filtrar elementos:</li> </ul> <pre><code>val numeros = intArrayOf(1, 2, 3, 4, 5)\nval pares = numeros.filter { it % 2 == 0 }\nprintln(pares)\n</code></pre>"},{"location":"unidades/ud01/ud01/#12-excepciones","title":"12. Excepciones","text":"<p>Una excepci\u00f3n es un error que ocurre en tiempo de ejecuci\u00f3n y que interrumpe el flujo normal del programa.</p> <pre><code>fun main() {\n    try {\n        val resultado = 10 / 0\n        println(\"Resultado: $resultado\")\n    } catch (e1: ArithmeticException) {\n        println(\"Error: Divisi\u00f3n entre cero\")\n    } catch (e2: Exception) {\n        println(\"Otro error\")\n    } finally {\n        println(\"Fin del bloque try-catch\")\n    }\n}\n</code></pre>"},{"location":"unidades/ud01/ud01/#13-package-e-import","title":"13. Package e import","text":"<p>Un package es una forma de agrupar clases, funciones, objetos y otros archivos relacionados bajo un mismo nombre. La palabra clave import se usa para acceder a clases, funciones u objetos definidos en otros paquetes.</p> <ul> <li>Ejemplo 1 - package e import:</li> </ul> <pre><code>package com.ejemplo.app\nimport com.ejemplo.util.saludar\nfun main() {\n   println(saludar(\"Mundo\"))\n}\n</code></pre> <ul> <li>Ejemplo 2 - import ... as ... (alias):</li> </ul> <pre><code>import com.ejemplo.util.saludar as saludoUtil\nfun main() {\n   println(saludoUtil(\"Pol\"))\n}\n</code></pre> <ul> <li>Ejemplo 3 - Importar todo un paquete (<code>*</code>):</li> </ul> <pre><code>import com.ejemplo.util.*\n</code></pre> <ul> <li>Ejemplo completo:</li> </ul> <pre><code>package util\nfun saludar(nombre: String): String {\n   return \"\u00a1Hola, $nombre!\"\n}\nfun despedir(nombre: String): String {\n   return \"Adi\u00f3s, $nombre.\"\n}\npackage util\nfun sumar(a: Int, b: Int): Int = a + b\nfun multiplicar(a: Int, b: Int): Int = a * b\npackage app\nimport util.saludar\nimport util.despedir\nimport util.sumar\nimport util.multiplicar\nfun main() {\n   val nombre = \"Kotlin\"\n    println(saludar(nombre))\n   println(\"Suma: ${sumar(3, 5)}\")\n   println(\"Multiplicaci\u00f3n: ${multiplicar(4, 6)}\")\n    println(despedir(nombre))\n}\n</code></pre>"},{"location":"unidades/ud02/documentacion_final/","title":"Documentaci\u00f3n final","text":""},{"location":"unidades/ud02/documentacion_final/#7-documentacion-el-fichero-leememd","title":"7. Documentaci\u00f3n: El Fichero LEEME.md","text":"<p>En un proyecto de software el c\u00f3digo fuente por s\u00ed solo no cuenta toda la historia y es fundamental crear documentaci\u00f3n adicional. La forma est\u00e1ndar y m\u00e1s extendida de hacerlo es a trav\u00e9s de un fichero <code>LEEME.md</code> (o <code>README.md</code>). Un proyecto sin un <code>LEEME.md</code> se considera incompleto o poco profesional.</p> <p>El fichero <code>LEEME.md</code> es lo primero que ver\u00e1 cualquier persona (incluido nuestro \"yo\" del futuro) que quiera entender nuestro c\u00f3digo. Es buena pr\u00e1ctica explicar qu\u00e9 hace el proyecto, c\u00f3mo se utiliza y por qu\u00e9 se tomaron algunas decisiones, por ejemplo \u00bfpor qu\u00e9 elegimos un registro de 36 bytes?\u201d o \u201c\u00bfpor qu\u00e9 el nombre del fichero es registros.dat?\".</p> <p>Un buen fichero <code>LEEME.md</code> deber\u00eda contener, como m\u00ednimo, las siguientes secciones: * Nombre del proyecto y breve descripci\u00f3n. * Estructura de Datos: En esta secci\u00f3n se explica el dise\u00f1o de los datos. * Instrucciones de Ejecuci\u00f3n: Pasos claros y sencillos para que otra persona pueda ejecutar nuestro programa. * Decisiones de Dise\u00f1o (Opcional pero Recomendado): Un peque\u00f1o apartado para explicar brevemente por qu\u00e9 tomamos ciertas decisiones.</p> <p>La extensi\u00f3n <code>.md</code> significa Markdown que es un lenguaje de marcado ligero que permite dar formato a un texto plano usando caracteres simples. Podemos crearlo con cualquier editor de texto (IntelliJ, VSCode, Bloc de notas...) y guardarlo con la extensi\u00f3n <code>.md</code>. Plataformas como GitHub, GitLab y otros sistemas de documentaci\u00f3n convierten estos ficheros en p\u00e1ginas web.</p>"},{"location":"unidades/ud02/documentacion_final/#sintaxis-basica-de-markdown-para-empezar","title":"Sintaxis b\u00e1sica de Markdown para empezar","text":"<pre><code># T\u00edtulo de Nivel 1\n## T\u00edtulo de Nivel 2\n### T\u00edtulo de Nivel 3\n**Texto en negrita**\n*Texto en cursiva*\n- Elemento de una lista\n1. Elemento de una lista numerad\n</code></pre> <p>Para bloques de c\u00f3digo, rodearlos con tres comillas invertidas (```) y especificar el lenguaje: <pre><code>```kotlin\nfun main() {\n    println(\"Hola, Markdown!\")\n}\n```\n</code></pre></p>"},{"location":"unidades/ud02/documentacion_final/#ejemplo","title":"Ejemplo:","text":"<pre><code># Gestor de mediciones\nEste es un programa de consola desarrollado en Kotlin para gestionar una colecci\u00f3n de registros de mediciones de temperatura y humedad registradas por unos sensores.\nLos datos se almacenan en un fichero binario de acceso aleatorio llamado *mediciones.dat*\n\n## 1. Estructura de datos\n### **Data Class:**\n``` kotlin\ndata class Sensor(\n    val id_sensor: Int,\n    val nombre: String,\n    val temperatura: Double\n    val humedad: Double\n)\n</code></pre>"},{"location":"unidades/ud02/documentacion_final/#estructura-del-registro-binario","title":"Estructura del registro binario:","text":"<ul> <li>ID: Int - 4 bytes</li> <li>Nombre: String - 20 bytes (longitud fija)</li> <li>temperatura: Double - 8 bytes</li> <li>humedad: Double - 8 bytes</li> <li>Tama\u00f1o Total del Registro: 4 + 20 + 8 + 8 = 40 bytes</li> </ul>"},{"location":"unidades/ud02/documentacion_final/#2-instrucciones-de-ejecucion","title":"2. Instrucciones de ejecuci\u00f3n","text":"<ul> <li>Requisitos previos: Aseg\u00farate de tener un JDK (ej. versi\u00f3n 17 o superior) instalado.</li> <li>Compilaci\u00f3n: Abre el proyecto en IntelliJ IDEA y deja que Gradle sincronice las dependencias.</li> <li>Ejecuci\u00f3n: Ejecuta la funci\u00f3n main del fichero Main.kt.</li> <li>Ficheros necesarios: El programa espera encontrar un fichero datos_iniciales.csv en la carpeta datos_ini dentro de la ra\u00edz del proyecto para la carga inicial de datos.</li> </ul>"},{"location":"unidades/ud02/documentacion_final/#3-decisiones-de-diseno","title":"3. Decisiones de dise\u00f1o","text":"<ul> <li>Eleg\u00ed CSV para los datos iniciales porque es un formato muy f\u00e1cil de crear y editar manualmente con cualquier hoja de c\u00e1lculo.</li> <li>Decid\u00ed que el campo nombre tuviera 20 bytes porque considero que es suficiente para la mayor\u00eda de nombres de sensores sin desperdiciar demasiado espacio.</li> </ul>"},{"location":"unidades/ud02/ficheros_acceso_aleatorio/","title":"Ficheros de acceso aleatorio","text":""},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#6-ficheros-de-acceso-aleatorio","title":"6. Ficheros de acceso aleatorio","text":"<p>Un fichero de acceso aleatorio es un tipo de fichero que permite leer o escribir en cualquier posici\u00f3n del fichero directamente, sin necesidad de procesar secuencialmente todo el contenido previo. El sistema puede \u201csaltar\u201d a una posici\u00f3n concreta (medida en bytes desde el inicio del fichero) y comenzar la lectura o escritura desde ah\u00ed. Por ejemplo, si cada registro ocupa 200 bytes, para acceder al registro n\u00famero 100 hay que saltar 200\u00d799=19.800 bytes desde el inicio.</p> <p>Las clases FileChannel, ByteBuffer y StandardOpenOption se utilizan juntas para leer y escribir en ficheros binarios y en el acceso aleatorio a ficheros. <code>ByteBuffer</code> se utiliza en ficheros de acceso aleatorio porque permite leer y escribir bloques binarios de datos en posiciones espec\u00edficas del fichero.</p>"},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#metodos-de-filechannel","title":"M\u00e9todos de FileChannel","text":"M\u00e9todo Descripci\u00f3n <code>position()</code> Devuelve la posici\u00f3n actual del puntero en el fichero y permite saltar a cualquier posici\u00f3n en \u00e9l (tanto para leer como para escribir). <code>position(long)</code> Establece una posici\u00f3n exacta para lectura/escritura. <code>truncate(long)</code> Recorta o ampl\u00eda el tama\u00f1o del fichero. <code>size()</code> Devuelve el tama\u00f1o total actual del fichero. <code>read(ByteBuffer)</code>, <code>write(ByteBuffer)</code> Usa <code>FileChannel</code> para secuencial o aleatorio."},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#metodos-de-bytebuffer","title":"M\u00e9todos de ByteBuffer","text":"M\u00e9todo Descripci\u00f3n <code>allocate(capacidad)</code> Crea un buffer con capacidad fija en memoria (no compartida). <code>wrap(byteArray)</code> Crea un buffer que envuelve un array de bytes existente (memoria compartida). <code>wrap(byteArray, offset, length)</code> Crea un buffer desde una porci\u00f3n del array existente. <code>put(byte)</code>, <code>putInt(int)</code>, <code>putDouble(double)</code>, <code>putFloat(float)</code>, <code>putChar(char)</code>, <code>putShort(short)</code>, <code>putLong(long)</code> Escribe un byte, int, double, float, char, short o long en la posici\u00f3n actual. <code>put(byte[], offset, length)</code> Escribe una porci\u00f3n de un array de bytes. <code>get()</code>, <code>getInt()</code>, <code>getDouble()</code>, <code>getFloat()</code>, <code>getChar()</code>, <code>getShort()</code>, <code>getLong()</code> Lee un byte, int, double, float, char, short o long desde la posici\u00f3n actual. <code>get(byte[], offset, length)</code> Lee una porci\u00f3n del buffer a un array."},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#metodos-de-control-del-buffer","title":"M\u00e9todos de control del buffer","text":"M\u00e9todo Descripci\u00f3n <code>position()</code> Devuelve la posici\u00f3n actual del cursor. <code>position(int)</code> Establece la posici\u00f3n del cursor. <code>limit()</code> Devuelve el l\u00edmite del buffer. <code>limit(int)</code> Establece un nuevo l\u00edmite. <code>capacity()</code> Devuelve la capacidad total del buffer. <code>clear()</code> Limpia el buffer: posici\u00f3n a 0, l\u00edmite al m\u00e1ximo (sin borrar contenido). <code>flip()</code> Prepara el buffer para lectura despu\u00e9s de escribir. <code>rewind()</code> Posici\u00f3n a 0 para releer desde el inicio. <code>remaining</code> Indica cu\u00e1ntos elementos quedan por procesar. <code>hasRemaining()</code> <code>true</code> si a\u00fan queda contenido por leer o escribir. <p>IMPORTANTE: un fichero <code>.dat</code> no es un fichero de texto. No se puede abrir con el Bloc de Notas, TextEdit, o un editor de c\u00f3digo en modo texto normal. Si se abre con estos programas se ve una mezcla de caracteres extra\u00f1os, s\u00edmbolos y espacios (\"basura\"). Hay herramientas online y plugins para los IDE para poder abrir los ficheros y ver la informaci\u00f3n en binario que contienen.</p>"},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#ejemplo","title":"Ejemplo:","text":"<p>El siguiente ejemplo utiliza <code>FileChannel</code> y <code>ByteBuffer</code> para crear y leer un fichero llamado <code>mediciones.dat</code> con registros con la siguiente estructura:</p> <ul> <li>ID del sensor (<code>Int</code> - 4 bytes)</li> <li>temperatura (<code>Double</code> - 8 bytes)</li> <li>humedad (<code>Double</code> - 8 bytes)</li> </ul> <p>A continuaci\u00f3n se muestra el c\u00f3digo con las funciones para a\u00f1adir una medici\u00f3n al final del fichero y leer todas las mediciones que hay en \u00e9l. <pre><code>import java.nio.ByteBuffer // \"contenedor\" de bytes en memoria.\nimport java.nio.ByteOrder // especificar el orden de los bytes\nimport java.nio.channels.FileChannel //canal que conecta con el fichero\nimport java.nio.file.Files\nimport java.nio.file.Path\nimport java.nio.file.StandardOpenOption\nconst val TAMANO_ID = Int.SIZE_BYTES // 4 bytes\nconst val TAMANO_NOMBRE = 20 // String de tama\u00f1o fijo 20 bytes\nconst val TAMANO_TEMPERATURA = Double.SIZE_BYTES // 8 bytes\nconst val TAMANO_HUMEDAD = Double.SIZE_BYTES // 8 bytes\nconst val TAMANO_REGISTRO = TAMANO_ID + TAMANO_NOMBRE + TAMANO_TEMPERATURA + TAMANO_HUMEDAD\nfun main() {\n    val rutaFichero = Path.of(\"mediciones.dat\")\n    escribirMedicion(rutaFichero, 101, \"Atenea\",25.5, 60.2)\n    escribirMedicion(rutaFichero, 102, \"Hera\",26.1, 58.9)\n    escribirMedicion(rutaFichero, 103, \"Iris\",28.4, 65.9)\n    escribirMedicion(rutaFichero, 104, \"Selene\",28.4, 65.9)\n    leerMediciones(rutaFichero) //leer todas las mediciones\n}\n// Funci\u00f3n que escribe una medici\u00f3n en el fichero.\nfun escribirMedicion(ruta: Path, idSensor: Int, nombre: String, temperatura: Double, humedad: Double) {\n    /* .use { ... } abre el canal (se cerrar\u00e1 autom\u00e1ticamente al final del bloque) Escribir con APPEND para a\u00f1adir el final */\n    FileChannel.open(ruta, StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.APPEND).use { canal -&gt;\n        // Crear un ByteBuffer de nuestro tama\u00f1o y especificamos el orden de bytes\n        val buffer = ByteBuffer.allocate(TAMANO_REGISTRO)\n        buffer.order(ByteOrder.nativeOrder())\n        /* Escribimos los datos en el buffer en el orden correcto.\n        'put' avanza la \"posici\u00f3n\" interna del buffer.*/\n        buffer.putInt(idSensor) // Escribe 4 bytes\n        /* Para escribir el String hay que convertirlo a un array de bytes de tama\u00f1o fijo.\n        Inicializamos el array de bytes rellen\u00e1ndolo con el car\u00e1cter espacio.\n        ' '.code.toByte() convierte el car\u00e1cter espacio a su valor de byte.*/\n        val nombreCompleto = ByteArray(TAMANO_NOMBRE) { ' '.code.toByte() }\n        // Convertimos el String de entrada a un array de bytes temporal.\n        val nombreBytes = nombre.toByteArray(Charsets.UTF_8)\n        /* Copiamos los bytes del String al principio de nuestro array de tama\u00f1o fijo.\n        Si 'nombre' ocupa menos de 20 bytes, el resto de 'nombreCompleto' seguir\u00e1 relleno de espacios.\n        Si 'nombre' ocupa m\u00e1s de 20 bytes, solo se copiar\u00e1n los primeros 20.*/\n        nombreBytes.copyInto(nombreCompleto)\n        buffer.put(nombreCompleto) // Escribe 20 bytes\n        buffer.putDouble(temperatura) // Escribe 8 bytes\n        buffer.putDouble(humedad) // Escribe 8 bytes\n        /* 'flip()' prepara el buffer para ser le\u00eddo o escrito\n        Resetea la 'posici\u00f3n' a 0 y limita al tama\u00f1o total\n        El canal escribir\u00e1 desde la posici\u00f3n 0 hasta la 20 */\n        buffer.flip()\n        // Escribimos el contenido del buffer en el fichero a trav\u00e9s del canal.\n        canal.write(buffer)\n        println (\"Medici\u00f3n (ID: $idSensor) escrita correctamente.\")\n    }\n}\n// Funci\u00f3n que lee TODAS las mediciones almacenadas en el fichero.\nfun leerMediciones(ruta: Path) {\n    if (!Files.exists(ruta)) {\n        println (\"El fichero ${ruta.fileName} no existe. No hay nada que leer.\")\n    } else {\n        println (\"\\n--- Leyendo todas las mediciones ---\")\n        FileChannel.open(ruta, StandardOpenOption.READ).use { canal -&gt;\n            // Crear buffer\n            val buffer = ByteBuffer.allocate(TAMANO_REGISTRO)\n            buffer.order(ByteOrder.nativeOrder())\n            /* Leer del canal en un bucle hasta que se alcance el final del fichero.\n            canal.read(buffer) lee bytes del fichero y los guarda en el buffer.\n            Devuelve el n\u00famero de bytes le\u00eddos, o -1 si ya no hay m\u00e1s datos. */\n            while (canal.read(buffer) &gt; 0) {\n                /* Despu\u00e9s de `canal.read()` su posici\u00f3n est\u00e1 al final.\n                `flip()` resetear la posici\u00f3n a 0. Para poder leer\n                los datos que acabamos de cargar desde el principio del buffer. */\n                buffer.flip()\n                // Leemos los datos en el mismo orden en que los escribimos.\n                val id = buffer.getInt()\n                // Crear un array de bytes vac\u00edo para guardar los datos del nombre.\n                val nombreCompleto = ByteArray(TAMANO_NOMBRE)\n                // Leer 20 bytes del buffer y los guardamos en nuestro array.\n                buffer.get(nombreCompleto)\n                /* Convertir el array de bytes a un String. Usar .trim() para eliminar\n                los espacios en blanco que se escribieron al final */\n                val nombre = String(nombreCompleto, Charsets.UTF_8).trim()\n                val temp = buffer.getDouble()\n                val hum = buffer.getDouble()\n                println (\"  - ID: $id, Nombre: $nombre, Temperatura: $temp \u00b0C, Humedad: $hum %\")\n                // `clear()` resetea la posici\u00f3n a 0 y el l\u00edmite a la capacidad total.\n                buffer.clear()\n            }\n        }\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Medici\u00f3n (ID: 101) escrita correctamente.\nMedici\u00f3n (ID: 102) escrita correctamente.\nMedici\u00f3n (ID: 103) escrita correctamente.\nMedici\u00f3n (ID: 104) escrita correctamente.\n\n--- Leyendo todas las mediciones ---\n  - ID: 101, Nombre: Atenea, Temperatura: 25.5 \u00b0C, Humedad: 60.2 %\n  - ID: 102, Nombre: Hera, Temperatura: 26.1 \u00b0C, Humedad: 58.9 %\n  - ID: 103, Nombre: Iris, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n  - ID: 104, Nombre: Selene, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n</code></pre></p> <p>Ahora que ya tenemos la informaci\u00f3n guardada en nuestro fichero <code>.dat</code> y sabemos leerla, vamos a ampliar la aplicaci\u00f3n con una funci\u00f3n que recoge el ID del sensor a modificar y los nuevos datos de temperatura y humedad. Cuando localiza el registro del sensor cuyo ID coincide con el buscado, escribe los nuevos datos en las posiciones de los bytes correspondientes.</p> <pre><code>fun actualizarMedicion(ruta: Path, idSensorBuscado: Int, nuevaTemperatura: Double, nuevaHumedad: Double) {\n    if (!Files.exists(ruta)) {\n        println (\"Error: El fichero no existe, no se puede actualizar.\")\n    } else {\n        println (\"\\nIntentando actualizar medici\u00f3n para ID: $idSensorBuscado...\")\n        FileChannel.open(ruta, StandardOpenOption.READ, StandardOpenOption.WRITE).use { canal -&gt;\n            // Creamos un buffer peque\u00f1o, solo para leer el ID en cada iteraci\u00f3n.\n            // No necesitamos cargar el registro completo solo para buscar.\n            val buffer = ByteBuffer.allocate(TAMANO_ID)\n            buffer.order(ByteOrder.nativeOrder())\n            var posicionActual: Long = 0\n            var encontrado = false\n            while (canal.position() &lt; canal.size() &amp;&amp; !encontrado) {\n                // Guardar la posici\u00f3n del inicio del registro que estamos a punto de leer.\n                posicionActual = canal.position()\n\n                // Limpiamos y leemos solo los 4 bytes del ID.\n                buffer.clear()\n                canal.read(buffer)\n\n                // Preparamos el buffer para leer el entero.\n                buffer.flip()\n                val idActual = buffer.getInt()\n                println (\"leyendo ID: \" + idActual)\n                // Comparamos el ID le\u00eddo con el que estamos buscando.\n                if (idActual == idSensorBuscado) {\n                    encontrado = true\n                    println (\"Sensor $idSensorBuscado en posici\u00f3n $posicionActual.\")\n                    // Posici\u00f3n temperatura = inicio registro + tama\u00f1o del ID + tama\u00f1o nombre\n                    canal.position(posicionActual + TAMANO_ID + TAMANO_NOMBRE)\n                    val bufferDatos = ByteBuffer.allocate(TAMANO_TEMPERATURA + TAMANO_HUMEDAD)\n                    bufferDatos.order(ByteOrder.nativeOrder())\n                    bufferDatos.putDouble(nuevaTemperatura)\n                    bufferDatos.putDouble(nuevaHumedad)\n                    bufferDatos.flip()\n                    canal.write(bufferDatos)\n                    println (\"Medici\u00f3n actualizada con \u00e9xito a Temp: $nuevaTemperatura, Hum: $nuevaHumedad.\")\n                } else {\n                    canal.position(posicionActual + TAMANO_REGISTRO)\n                }\n            }\n            if (!encontrado) {\n                println (\"Medici\u00f3n con ID: $idSensorBuscado no encontrada\")\n            }\n        }\n    }\n}\n</code></pre> <p>La llamada a esta nueva funci\u00f3n en el main podr\u00eda ser: <pre><code>actualizarMedicion(rutaFichero, 102, 21.0, 72.3)\n</code></pre></p> <p>Se vuelve a llamar a <code>leerMediciones</code> para comprobar que la informaci\u00f3n del sensor se ha modificado correctamente: <pre><code>leerMediciones(rutaFichero)\n</code></pre></p> <p>\ud83d\udd0d Realiza los siguientes pasos:</p> <ul> <li>A\u00f1ade el c\u00f3digo de la funci\u00f3n <code>actualizarMedicion()</code> al proyecto del ejemplo anterior.</li> <li>Comenta en el <code>main</code> las llamadas a la funci\u00f3n <code>escribirMedicion()</code>.</li> <li>A\u00f1ade al <code>main</code> las llamadas a <code>actualizarMedicion()</code> y a <code>leerMediciones()</code>.</li> <li>Ejecuta la aplicaci\u00f3n y comprueba que la salida es la siguiente: <pre><code>--- Leyendo todas las mediciones ---\n  - ID: 101, Nombre: Atenea, Temperatura: 25.5 \u00b0C, Humedad: 60.2 %\n  - ID: 102, Nombre: Hera, Temperatura: 26.1 \u00b0C, Humedad: 58.9 %\n  - ID: 103, Nombre: Iris, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n  - ID: 104, Nombre: Selene, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n\nIntentando actualizar medici\u00f3n para ID: 102...\nleyendo ID: 101\nleyendo ID: 102\nSensor 102 en posici\u00f3n 40.\nMedici\u00f3n actualizada con \u00e9xito a Temp: 21.0, Hum: 72.3.\n\n--- Leyendo todas las mediciones ---\n  - ID: 101, Nombre: Atenea, Temperatura: 25.5 \u00b0C, Humedad: 60.2 %\n  - ID: 102, Nombre: Hera, Temperatura: 21.0 \u00b0C, Humedad: 72.3 %\n  - ID: 103, Nombre: Iris, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n  - ID: 104, Nombre: Selene, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n</code></pre></li> </ul> <p>Por \u00faltimo, ampliaremos la aplicaci\u00f3n para poder eliminar los datos de un sensor a partir de su ID. El programa recorre todo los registros comprobando si el ID coincide con el buscado. En caso de que no coincida escribe el registro en un fichero temporal y si coincide, no hace nada. Al finalizar el fichero temporal contendr\u00e1 los registros que no se quieren eliminar. Por \u00faltimo, se elimina el fichero original y se renombra el fichero temporal con el nombre original.</p> <pre><code>fun eliminarMedicion(ruta: Path, idSensorAEliminar: Int) {\n    val rutaTemp = Path.of(\"temp.dat\")\n    if (!Files.exists(ruta)) {\n        println (\"Error: El fichero no existe, no se puede actualizar.\")\n    } else {\n        println (\"\\nIntentando eliminar medici\u00f3n para el sensor con ID: $idSensorAEliminar...\")\n        FileChannel.open(ruta, StandardOpenOption.READ).use { canal -&gt;\n            // Crear buffer\n            val buffer = ByteBuffer.allocate(TAMANO_REGISTRO)\n            buffer.order(ByteOrder.nativeOrder())\n            /* Leer del canal en un bucle hasta que se alcance el final del fichero.\n            canal.read(buffer) lee bytes del fichero y los guarda en el buffer.\n            Devuelve el n\u00famero de bytes le\u00eddos, o -1 si ya no hay m\u00e1s datos. */\n            while (canal.read(buffer) &gt; 0) {\n                /* Despu\u00e9s de `canal.read()` su posici\u00f3n est\u00e1 al final.\n                `flip()` resetear la posici\u00f3n a 0. Para poder leer\n                los datos que acabamos de cargar desde el principio del buffer. */\n                buffer.flip()\n                // Leemos los datos en el mismo orden en que los escribimos.\n                val id = buffer.getInt()\n                // Crear un array de bytes vac\u00edo para guardar los datos del nombre.\n                val nombreCompleto = ByteArray(TAMANO_NOMBRE)\n                // Leer 20 bytes del buffer y los guardamos en nuestro array.\n                buffer.get(nombreCompleto)\n                /* Convertir el array de bytes a un String. Usar .trim() para eliminar\n                los espacios en blanco que se escribieron al final */\n                val nombre = String(nombreCompleto, Charsets.UTF_8).trim()\n                val temp = buffer.getDouble()\n                val hum = buffer.getDouble()\n                if (id!=idSensorAEliminar) {\n                    // Usar nuestra funci\u00f3n par escribir en el fichero temporal\n                    escribirMedicion(rutaTemp, id, nombre, temp, hum)\n                }\n                buffer.clear()\n            }\n        }\n        Files.delete(ruta) //borrar fichero original\n        Files.move(rutaTemp, ruta) // renombrar temporal\n    }\n}\n</code></pre> <p>La llamada a esta nueva funci\u00f3n en el main podr\u00eda ser: <pre><code>eliminarMedicion(rutaFichero, 102)\n</code></pre> Se vuelve a llamar a <code>leerMediciones</code> para comprobar que la informaci\u00f3n del sensor se ha modificado correctamente: <pre><code>leerMediciones(rutaFichero)\n</code></pre></p> <p>\ud83d\udd0d Realiza los siguientes pasos:</p> <ul> <li>A\u00f1ade el c\u00f3digo de la funci\u00f3n <code>eliminarMedicion()</code> al ejemplo anterior.</li> <li>Comenta en el <code>main</code> la llamada a la funci\u00f3n <code>actualizarMedicion()</code>.</li> <li>A\u00f1ade al <code>main</code> la llamada a <code>eliminarMedicion()</code>.</li> <li>Ejecuta la aplicaci\u00f3n y comprueba que la salida es la siguiente: <pre><code>--- Leyendo todas las mediciones ---\n  - ID: 101, Nombre: Atenea, Temperatura: 25.5 \u00b0C, Humedad: 60.2 %\n  - ID: 102, Nombre: Hera, Temperatura: 21.0 \u00b0C, Humedad: 72.3 %\n  - ID: 103, Nombre: Iris, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n  - ID: 104, Nombre: Selene, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n\nIntentando eliminar medici\u00f3n para el sensor con ID: 102...\nMedici\u00f3n (ID: 101) escrita correctamente.\nMedici\u00f3n (ID: 103) escrita correctamente.\nMedici\u00f3n (ID: 104) escrita correctamente.\n\n--- Leyendo todas las mediciones ---\n  - ID: 101, Nombre: Atenea, Temperatura: 25.5 \u00b0C, Humedad: 60.2 %\n  - ID: 103, Nombre: Iris, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n  - ID: 104, Nombre: Selene, Temperatura: 28.4 \u00b0C, Humedad: 65.9 %\n</code></pre></li> </ul>"},{"location":"unidades/ud02/ficheros_acceso_aleatorio/#practica-5-modificar-y-eliminar-registros-en-ficheros-dat","title":"\ud83c\udfaf Pr\u00e1ctica 5: Modificar y eliminar registros en ficheros .dat","text":"<p>Realiza lo siguiente: * Crea la funci\u00f3n <code>modificarReg()</code>: Pedir\u00e1 al usuario el ID del registro a modificar y buscar\u00e1 ese registro en el fichero. Si lo encuentra, pedir\u00e1 los nuevos datos. Utilizar\u00e1 acceso aleatorio (<code>FileChannel.position()</code>) para saltar a la posici\u00f3n exacta de ese registro y sobrescribir \u00fanicamente los campos modificados, sin alterar el resto del fichero. * Crea la funci\u00f3n <code>eliminarReg()</code>: Debe recibir un ID y eliminar el registro correspondiente. Implementa la t\u00e9cnica de streaming (leer el fichero original registro a registro, escribir los que se conservan en un fichero temporal, borrar el original y renombrar el temporal). * Comprueba: Prueba estas funciones desde <code>main</code>, llamando a <code>mostrarTodo()</code> antes y despu\u00e9s de cada operaci\u00f3n para verificar los resultados.</p>"},{"location":"unidades/ud02/ficheros_binarios/","title":"Ficheros binarios","text":""},{"location":"unidades/ud02/ficheros_binarios/#5-ficheros-binarios","title":"5. Ficheros binarios","text":"<p>Los ficheros binarios no son legibles directamente por humanos (.exe, .jpg, .mp3, .dat). En ellos los datos pueden estar no estructurados o estructurados.</p>"},{"location":"unidades/ud02/ficheros_binarios/#51-ficheros-binarios-no-estructurados","title":"5.1. Ficheros binarios no estructurados","text":"<p>En los ficheros binarios no estructurados los datos se escriben \u201ctal cual\u201d en bytes, sin un formato estructurado definido por un est\u00e1ndar. El programa que los lee necesita saber c\u00f3mo interpretar esos bytes.</p>"},{"location":"unidades/ud02/ficheros_binarios/#metodos-de-ficheros-binarios-no-estructurados","title":"M\u00e9todos de Ficheros Binarios No Estructurados","text":"M\u00e9todo Descripci\u00f3n <code>Files.readAllBytes(Path)</code>, <code>Files.write(Path, ByteArray)</code> Lee y escribe bytes puros. <code>Files.newInputStream(Path)</code>, <code>Files.newOutputStream(Path)</code> Flujo de bytes directo."},{"location":"unidades/ud02/ficheros_binarios/#ejemplo-binario-no-estructurado","title":"Ejemplo binario no estructurado:","text":"<p>Escribir bit a bit los datos <code>1 2 3 4 5</code> en un fichero llamado <code>datos.bin</code>. <pre><code>import java.io.IOException\nimport java.nio.file.Files\nimport java.nio.file.Path\nfun main() {\n    val ruta = Path.of(\"multimedia/bin/datos.bin\")\n    try {\n        // Asegura que el directorio 'documentos' existe\n        val directorio = ruta.parent\n        if (directorio != null &amp;&amp; !Files.exists(directorio)) {\n            Files.createDirectories(directorio)\n            println (\"Directorio creado: ${directorio.toAbsolutePath()}\")\n        }\n        // Verifica si se puede escribir\n        if (!Files.isWritable(directorio)) {\n            println (\"No se tienen permisos de escritura en el directorio: $directorio\")\n        } else {\n            // Datos a escribir\n            val datos = byteArrayOf(1, 2, 3, 4, 5)\n            Files.write(ruta, datos)\n            println (\"Fichero binario creado: ${ruta.toAbsolutePath()}\")\n            // Verifica si se puede leer\n            if (!Files.isReadable(ruta)) {\n                println (\"No se tienen permisos de lectura para el fichero: $ruta\")\n            } else {\n                // Lectura del fichero binario\n                val bytes = Files.readAllBytes(ruta)\n                println (\"Contenido le\u00eddo (byte a byte):\")\n                for (b in bytes) {\n                    print (\"$b \")\n                }\n            }\n        }\n    } catch (e: IOException) {\n        println (\"Ocurri\u00f3 un error de entrada/salida: ${e.message}\")\n    } catch (e: SecurityException) {\n        println (\"No se tienen permisos suficientes: ${e.message}\")\n    } catch (e: Exception) {\n        println (\"Error inesperado: ${e.message}\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Directorio creado: F:\\kot\\1-ficheros\\ejemplos1\\multimedia\\bin\nFichero binario creado: F:\\kot\\1-ficheros\\ejemplos1\\multimedia\\bin\\datos.bin\nContenido le\u00eddo (byte a byte):\n1 2 3 4 5\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_binarios/#52-ficheros-binarios-estructurados","title":"5.2. Ficheros binarios estructurados","text":"<p>En los ficheros binarios estructurados los datos se guardan de forma estructurada siguiendo una organizaci\u00f3n predefinida, con campos y tipos de datos, a veces con un formato est\u00e1ndar (ej. PNG, ZIP, MP3, etc.) que pueden incluir cabeceras (con informaci\u00f3n como versi\u00f3n, tama\u00f1o, etc.) y registros (con campos fijos o delimitadores). El orden de bytes y los tama\u00f1os est\u00e1n definidos, lo que permite a cualquier programa que conozca el formato leerlo correctamente. Las clases <code>DataOutputStream</code> y <code>DataInputStream</code> de java.io sirven para leer y escribir ficheros binarios estructurados.</p>"},{"location":"unidades/ud02/ficheros_binarios/#metodos-de-dataoutputstream","title":"M\u00e9todos de DataOutputStream","text":"M\u00e9todo Descripci\u00f3n <code>writeInt(int)</code> Escribe un entero con signo. Entero (4 bytes). <code>writeDouble(double)</code> Escribe un n\u00famero en coma flotante. Decimal (8 bytes). <code>writeFloat(float)</code> Escribe un n\u00famero float. Decimal (4 bytes). <code>writeLong(long)</code> Escribe un long. Entero largo (8 bytes). <code>writeBoolean(boolean)</code> Escribe un valor verdadero/falso. Booleano (1 byte). <code>writeChar(char)</code> Escribe un car\u00e1cter Unicode. Car\u00e1cter (2 bytes). <code>writeUTF(String)</code> Escribe una cadena precedida por su longitud en 2 bytes. Cadena UTF-8. <code>writeByte(int)</code> Escribe un solo byte. Byte (1 byte). <code>writeShort(int)</code> Escribe un short. Entero corto (2 bytes)."},{"location":"unidades/ud02/ficheros_binarios/#metodos-de-datainputstream","title":"M\u00e9todos de DataInputStream","text":"M\u00e9todo Descripci\u00f3n <code>readInt()</code> Lee un entero con signo (Entero). <code>readDouble()</code> Lee un n\u00famero double (Decimal). <code>readFloat()</code> Lee un n\u00famero float (Decimal). <code>readLong()</code> Lee un long (Entero largo). <code>readBoolean()</code> Lee un valor verdadero/falso (Booleano). <code>readChar()</code> Lee un car\u00e1cter Unicode (Car\u00e1cter). <code>readUTF()</code> Lee una cadena UTF-8 (Cadena UTF-8). <code>readByte()</code> Lee un byte (Byte). <code>readShort()</code> Lee un short (Entero corto)."},{"location":"unidades/ud02/ficheros_binarios/#ejemplo","title":"Ejemplo:","text":"<p>Lectura y escritura en ficheros binarios estructurados (con tipos primitivos): <pre><code>import java.io.DataInputStream\nimport java.io.DataOutputStream\nimport java.io.FileInputStream\nimport java.io.FileOutputStream\nimport java.nio.file.Files\nimport java.nio.file.Path\nfun main() {\n    val ruta = Path.of(\"multimedia/binario.dat\")\n    Files.createDirectories(ruta.parent)\n    // Escritura binaria\n    val fos = FileOutputStream(ruta.toFile())\n    val out = DataOutputStream(fos)\n    out.writeInt(42) // int (4 bytes)\n    out.writeDouble(3.1416) // double (8 bytes)\n    out.writeUTF(\"K\") // char (2 bytes)\n    out.close()\n    fos.close()\n    println (\"Fichero binario escrito con DataOutputStream.\")\n    // Lectura binaria\n    val fis = FileInputStream(ruta.toFile())\n    val input = DataInputStream(fis)\n    val entero = input.readInt()\n    val decimal = input.readDouble()\n    val caracter = input.readUTF()\n    input.close()\n    fis.close()\n    println (\"Contenido le\u00eddo:\")\n    println (\"  Int: $entero\")\n    println (\"  Double: $decimal\")\n    println (\"  Char: $caracter\")\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Fichero binario escrito con DataOutputStream.\nContenido le\u00eddo:\n  Int: 42\n  Double: 3.1416\n  Char: K\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_binarios/#53-ficheros-de-imagenes","title":"5.3. Ficheros de im\u00e1genes","text":"<p>Las im\u00e1genes son ficheros binarios que contienen datos que representan gr\u00e1ficamente una imagen visual (fotograf\u00edas, ilustraciones, etc.). A diferencia de los ficheros de texto o binarios crudos, un fichero de imagen tiene estructura interna que depende del formato.</p> <p>Algunos de los m\u00e1s comunes son: * <code>.jpg</code>: Comprimido con p\u00e9rdida, ideal para fotos. * <code>.png</code>: Comprimido sin p\u00e9rdida, soporta transparencia. * <code>.bmp</code>: Sin compresi\u00f3n, ocupa m\u00e1s espacio. * <code>.gif</code>: Admite animaciones simples, limitada a 256 colores.</p>"},{"location":"unidades/ud02/ficheros_binarios/#metodos-de-ficheros-de-imagenes","title":"M\u00e9todos de Ficheros de Im\u00e1genes","text":"M\u00e9todo Descripci\u00f3n <code>ImageIO.read(Path/File)</code>, <code>ImageIO.write(BufferedImage, ...)</code> Usa <code>javax.imageio.ImageIO</code>."},{"location":"unidades/ud02/ficheros_binarios/#ejemplo-que-genera-una-imagen","title":"Ejemplo que genera una imagen:","text":"<p><pre><code>import java.awt.Color\nimport java.awt.image.BufferedImage\nimport java.io.File\nimport javax.imageio.ImageIO\nfun main() {\n    val ancho = 200\n    val alto = 100\n    val imagen = BufferedImage(ancho, alto, BufferedImage.TYPE_INT_RGB)\n    // Rellenar la imagen con colores\n    for (x in 0 until ancho) {\n        for (y in 0 until alto) {\n            val rojo = (x * 255) / ancho\n            val verde = (y * 255) / alto\n            val azul = 128\n            val color = Color(rojo, verde, azul)\n            imagen.setRGB(x, y, color.rgb)\n        }\n    }\n    // Guardar la imagen\n    val archivo = File(\"multimedia/imagen_generada.png\")\n    ImageIO.write(imagen, \"png\", archivo)\n    println (\"Imagen generada correctamente: ${archivo.absolutePath}\")\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y verifica que se crea la imagen correctamente.</p>"},{"location":"unidades/ud02/ficheros_binarios/#ejemplo-que-convierte-una-imagen-a-escala-de-grises","title":"Ejemplo que convierte una imagen a escala de grises:","text":"<p><pre><code>import java.awt.Color\nimport java.awt.image.BufferedImage\nimport java.nio.file.Files\nimport java.nio.file.Path\nimport java.nio.file.StandardCopyOption\nimport javax.imageio.ImageIO\nfun main() {\n    val originalPath = Path.of(\"multimedia/jpg/amanecer1.jpg\")\n    val copiaPath = Path.of(\"multimedia/jpg/amanecer1_copia.jpg\")\n    val grisPath = Path.of(\"multimedia/jpg/amanecer1_escala_de_grises.png\")\n    // 1. Comprobar si la imagen existe\n    if (!Files.exists(originalPath)) {\n        println (\"No se encuentra la imagen original: $originalPath\")\n    } else {\n        // 2. Copiar la imagen con java.nio (para no modificar el original)\n        Files.copy(originalPath, copiaPath, StandardCopyOption.REPLACE_EXISTING)\n        println (\"Imagen copiada a: $copiaPath\")\n        // 3. Leer la imagen en un objeto BufferedImage\n        val imagen: BufferedImage = ImageIO.read(copiaPath.toFile())\n        // 4. Convertir a escala de grises, p\u00edxel por p\u00edxel\n        for (x in 0 until imagen.width) {\n            for (y in 0 until imagen.height) {\n                // Obtenemos el color del p\u00edxel actual.\n                val color = Color(imagen.getRGB(x, y))\n                /* Calcular el valor de gris usando la f\u00f3rmula de luminosidad.\n                Esta f\u00f3rmula pondera los colores rojo, verde y azul seg\u00fan la sensibilidad del ojo humano.\n                El resultado es un \u00fanico valor de brillo que convertimos a entero. */\n                val gris = (color.red * 0.299 + color.green * 0.587 + color.blue * 0.114).toInt()\n                // Creamos un nuevo color donde los componentes rojo, verde y azul\n                // son todos iguales al valor de 'gris' que hemos calculado.\n                val colorGris = Color(gris, gris, gris)\n                // Establecemos el nuevo color gris en el p\u00edxel de la imagen.\n                imagen.setRGB(x, y, colorGris.rgb)\n            }\n        }\n        // 5. Guardar la imagen modificada\n        // Usamos \"png\" porque es un formato sin p\u00e9rdida, ideal para im\u00e1genes generadas.\n        ImageIO.write(imagen, \"png\", grisPath.toFile())\n        println (\"Imagen convertida a escala de grises y guardada como: $grisPath\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y verifica que la imagen generada es la misma que la original pero en tonos de grises.</p>"},{"location":"unidades/ud02/ficheros_directorios/","title":"Ficheros y directorios","text":""},{"location":"unidades/ud02/ficheros_directorios/#2-gestion-de-ficheros-y-directorios","title":"2. Gesti\u00f3n de ficheros y directorios","text":"<p>La gesti\u00f3n de ficheros y directorios se realiza a trav\u00e9s de Path y Files.</p> <ul> <li>Path: Representa una ruta en el sistema de ficheros (ej. <code>/home/usuario/foto.png</code> o <code>C:\\usuarios\\docs\\informe.txt</code>). Un objeto Path es una direcci\u00f3n y no significa que el fichero o directorio exista.</li> </ul>"},{"location":"unidades/ud02/ficheros_directorios/#metodos-principales-de-path","title":"M\u00e9todos principales de Path","text":"M\u00e9todo Descripci\u00f3n <code>Path.of(String)</code> Crea un objeto <code>Path</code> a partir de un String de ruta (Java 11+). Por debajo llama a <code>Paths.get()</code> que es el m\u00e9todo original de la clase <code>Paths</code> (Java 7+). <code>toString()</code> Devuelve la ruta como un <code>String</code> (se llama por defecto desde <code>println</code>). <code>toAbsolutePath()</code> Devuelve la ruta absoluta del Path. <code>fileName()</code> Devuelve el nombre del fichero o directorio final de la ruta."},{"location":"unidades/ud02/ficheros_directorios/#ejemplo-1","title":"Ejemplo 1","text":"<p><pre><code>import java.nio.file.Path\nfun main() {\n    // Path relativo al directorio del proyecto\n    val rutaRelativa: Path = Path.of(\"documentos\", \"ejemplo.txt\")\n    // Path absoluto en Windows\n    val rutaAbsolutaWin: Path = Path.of(\"C:\", \"Users\", \"Pol\", \"Documentos\")\n    // Path absoluto en Linux/macOS\n    val rutaAbsolutaNix: Path = Path.of(\"/home/pol/documentos\")\n    println (\"Ruta relativa: \" + rutaRelativa)\n    println (\"Ruta absoluta: \" + rutaRelativa.toAbsolutePath())\n    println (\"Ruta absoluta: \" + rutaAbsolutaWin)\n    println (\"Ruta absoluta: \" + rutaAbsolutaNix)\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Ruta relativa: documentos\\ejemplo.txt\nRuta absoluta: F:\\kot\\1-ficheros\\documentos\\ejemplo.txt\nRuta absoluta: C:\\Users\\Pol\\Documentos\nRuta absoluta: \\home\\pol\\documentos\n</code></pre></p> <ul> <li>Files: Es una clase de utilidad con las acciones (borrar, copiar, mover, leer, etc) que podemos realizar sobre las rutas (<code>Path</code>).</li> </ul>"},{"location":"unidades/ud02/ficheros_directorios/#metodos-principales-de-files","title":"M\u00e9todos principales de Files","text":"M\u00e9todo Descripci\u00f3n <code>exists()</code>, <code>isDirectory()</code>, <code>isRegularFile()</code>, <code>isReadable()</code> Verificar de existencia y accesibilidad. <code>list()</code>, <code>walk()</code> Listar contenido de un directorio. <code>readAttributes()</code> Obtener atributos (tama\u00f1o, fecha, etc.). <code>createDirectory()</code> Crear un directorio: Solo crea el directorio y espera que todo el \"camino\" hasta \u00e9l ya exista. <code>createDirectories</code> Crea un directorio y tambi\u00e9n los directorios padre si no existen. Es la forma m\u00e1s segura. <code>createFile()</code> Crear un fichero. <code>delete()</code> Borrar un fichero o directorio (lanza una excepci\u00f3n si el borrado falla). Lanza la excepci\u00f3n <code>NoSuchFileException</code> si el fichero o directorio no existe. Es m\u00e1s seguro <code>deleteIfExists()</code>. <code>move(origen, destino)</code> Mover o renombrar un fichero o directorio. <code>copy(origen, destino)</code> Copiar un fichero o directorio. Si el destino ya existe se puede sobreescribir utilizando <code>copy(Path, Path, REPLACE_EXISTING)</code>. Si se copia un directorio no se copiar\u00e1 su contenido, el nuevo directorio estar\u00e1 vac\u00edo."},{"location":"unidades/ud02/ficheros_directorios/#ejemplo-2","title":"Ejemplo 2","text":"<p>El siguiente ejemplo es un organizador de ficheros. Imagina una carpeta de \"multimedia\" donde todo est\u00e1 desordenado. El programa organizar\u00e1 los ficheros en subcarpetas seg\u00fan su extensi\u00f3n (.pdf, .jpg, .mp3, etc).</p> <p><pre><code>import java.nio.file.Files\nimport java.nio.file.Path\nimport java.nio.file.StandardCopyOption\nimport kotlin.io.path.extension // Extensi\u00f3n de Kotlin para obtener la extensi\u00f3n\nfun main() {\n    // 1. Ruta de la carpeta a organizar\n    val carpeta = Path.of(\"multimedia\")\n    println (\"--- Iniciando la organizaci\u00f3n de la carpeta: \" + carpeta + \"---\")\n    try {\n        // 2. Recorrer la carpeta desordenada y utilizar .use para asegurar que los recursos del sistema se cierren correctamente\n        Files.list(carpeta).use { streamDePaths -&gt;\n            streamDePaths.forEach { pathFichero -&gt;\n                // 3. Solo interesan los ficheros, ignorar subcarpetas\n                if (Files.isRegularFile(pathFichero)) {\n                    // 4. Obteners la extensi\u00f3n del fichero (ej: \"pdf\", \"jpg\")\n                    val extension = pathFichero.extension.lowercase()\n                    if (extension.isBlank()) {\n                        println (\"-&gt; Ignorando: \" + pathFichero.fileName)\n                        return@forEach // Salta a la siguiente iteraci\u00f3n del bucle\n                    }\n                    // 5. Crear la ruta del directorio de destino\n                    val carpetaDestino = carpeta.resolve(extension)\n                    // 6. Crear el directorio de destino si no existe\n                    if (Files.notExists(carpetaDestino)) {\n                        println (\"-&gt; Creando nueva carpeta \" + extension)\n                        Files.createDirectories(carpetaDestino)\n                    }\n                    // 7. Mover el fichero a su nueva carpeta\n                    val pathDestino = carpetaDestino.resolve(pathFichero.fileName)\n                    Files.move(pathFichero, pathDestino, StandardCopyOption.REPLACE_EXISTING)\n                    println (\"-&gt; Moviendo \" + pathFichero.fileName + \" a \" + extension)\n                }\n            }\n        }\n        println (\"\\n--- \u00a1Organizaci\u00f3n completada con \u00e9xito! ---\")\n    } catch (e: Exception) {\n        println (\"\\n--- Ocurri\u00f3 un error durante la organizaci\u00f3n ---\")\n        e.printStackTrace()\n    }\n}\n</code></pre> \ud83d\udd0d Crea una carpeta, dentro de tu proyecto llamada <code>multimedia</code> y guarda diferentes archivos (pdf, jpg, txt, etc.). Ejecuta el ejemplo anterior y comprueba que la salida es parecida a la siguiente.</p> <pre><code>--- Iniciando la organizaci\u00f3n de la carpeta: multimedia---\n-&gt; Creando nueva carpeta jpg\n-&gt; Moviendo 20191106_071048.jpg a jpg\n-&gt; Moviendo 20191101_071830.jpg a jpg\n-&gt; Creando nueva carpeta txt\n-&gt; Moviendo libros.txt a txt\n-&gt; Moviendo peliculas.txt a txt\n-&gt; Creando nueva carpeta pdf\n-&gt; Moviendo lorem-ipsum-2.pdf a pdf\n-&gt; Moviendo lorem-ipsum-1.pdf a pdf\n-&gt; Creando nueva carpeta mp3\n-&gt; Moviendo dark-cinematic-atmosphere.mp3 a mp3\n-&gt; Moviendo pad-harmonious-and-soothing-voice-like-background.mp3 a mp3\n\n--- \u00a1Organizaci\u00f3n completada con \u00e9xito! ---\n</code></pre> <p>En el ejemplo anterior hemos recorrido un directorio para organizar los ficheros que conten\u00eda. Recorrer un directorio para \"mirar\" su contenido es \u00fatil en muchas situaciones y hay varias formas de hacerlo. A continuaci\u00f3n veremos algunas:</p> <ul> <li><code>Files.list(path)</code>: Es la utilizada en el ejemplo anterior. Lista \u00fanicamente el contenido de un directorio sin acceder a las subcarpetas. Ser\u00e1 \u00fatil cuando solamente sea necesario acceder al contenido directo de una carpeta, por ejemplo para organizar ficheros en un directorio, mostrar el contenido de la carpeta actual o buscar un fichero espec\u00edfico solo en este nivel.<ul> <li>Ventajas:<ul> <li>R\u00e1pido y eficiente al no ser recursivo.</li> <li>Ofrece un control preciso, operando solo en el primer nivel del directorio.</li> <li>Devuelve un <code>Stream</code> de Java que permite usar operadores funcionales (<code>filter</code>, <code>map</code>, etc.) de forma segura con <code>.use</code>.</li> </ul> </li> <li>Inconvenientes:<ul> <li>No explora subdirectorios.</li> <li>Para recorrer un \u00e1rbol completo, se necesita implementar l\u00f3gica recursiva manualmente.</li> </ul> </li> </ul> </li> <li><code>Files.walk(path)</code>: Recorre un directorio y todo su contenido recursivamente. Entra en cada subcarpeta, y en sus subcarpetas hasta el final. Ser\u00e1 \u00fatil para operar sobre un directorio y todo lo que contiene, sin importar la profundidad, por ejemplo para buscar un fichero por nombre en cualquier subcarpeta, eliminar todos los ficheros temporales de un proyecto o contar todos los ficheros .kt de un repositorio.<ul> <li>Ventajas:<ul> <li>Recorre \u00e1rboles de directorios completos (recursivo) de forma muy sencilla.</li> <li>Extremadamente potente para b\u00fasquedas profundas o aplicar operaciones a todos los elementos anidados.</li> <li>Tambi\u00e9n devuelve un <code>Stream</code>, permitiendo un filtrado y procesamiento muy expresivo.</li> </ul> </li> <li>Inconvenientes:<ul> <li>Puede ser lento y consumir m\u00e1s memoria en directorios con miles de ficheros.</li> <li>Es una herramienta excesiva ('overkill') para tareas que solo requieren acceder al nivel actual.</li> </ul> </li> </ul> </li> <li><code>Files.newDirectoryStream(path)</code>: Es similar a <code>Files.list()</code>, listando solo el contenido inmediato. La diferencia es que no devuelve un <code>Stream</code> de Java 8 (que permite usar <code>.filter</code>, <code>.forEach</code>, etc.), sino un <code>DirectoryStream</code>, que es una versi\u00f3n m\u00e1s antigua que se usa con bucles for. Es menos com\u00fan en c\u00f3digo Kotlin moderno, pero es bueno reconocerlo para poder entender en proyectos antiguos (legacy). Para cualquier tarea nueva, <code>Files.list()</code> y <code>Files.walk()</code> son superiores en seguridad y expresividad.<ul> <li>Ventajas:<ul> <li>Utiliza un bucle <code>for-each</code> tradicional, que puede resultar familiar.</li> </ul> </li> <li>Inconvenientes:<ul> <li>\u00a1PELIGRO! Requiere cerrar el recurso manualmente (<code>.close()</code>). Si se olvida, provoca fugas de recursos (<code>resource leaks</code>).</li> <li>Es menos expresivo que los Streams. No se pueden encadenar operadores funcionales f\u00e1cilmente.</li> <li>Considerado obsoleto en c\u00f3digo Kotlin idiom\u00e1tico, que prefiere <code>Files.list().use{...}</code>.</li> </ul> </li> </ul> </li> </ul>"},{"location":"unidades/ud02/ficheros_directorios/#ejemplo-3","title":"Ejemplo 3","text":"<p>Queremos crear un informe de toda la estructura de la carpeta resultante del ejemplo anterior. Por tanto necesitamos entrar en las nuevas carpetas (pdf, jpg, txt) y ver qu\u00e9 ficheros hay dentro de cada una. Para ello se utiliza <code>Files.walk()</code> que calcula la profundidad, recorre la jerarqu\u00eda de carpetas y muestra cada elemento indicando si es un directorio o un fichero.</p> <p><pre><code>import java.nio.file.Files\nimport java.nio.file.Path\nfun main() {\n    val carpetaPrincipal = Path.of(\"multimedia\")\n    println (\"--- Mostrando la estructura final con Files.walk() ---\")\n    try {\n        Files.walk(carpetaPrincipal).use { stream -&gt;\n            // Ordenar el stream para una visualizaci\u00f3n m\u00e1s predecible\n            stream.sorted().forEach { path -&gt;\n                // Calcular profundidad para la indentaci\u00f3n\n                // Restamos el n\u00famero de componentes de la ruta base para que el directorio principal no tenga indentaci\u00f3n\n                val profundidad = path.nameCount - carpetaPrincipal.nameCount\n                val indentacion = \"\\t\".repeat(profundidad)\n                // Determinamos si es directorio o fichero para el prefijo\n                val prefijo = if (Files.isDirectory(path)) \"[DIR]\" else \"[FILE]\"\n                // No imprimimos la propia carpeta ra\u00edz, solo su contenido\n                if (profundidad &gt; 0) {\n                    println (\"$indentacion$prefijo ${path.fileName}\")\n                }\n            }\n        }\n    } catch (e: Exception) {\n        println (\"\\n--- Ocurri\u00f3 un error durante el recorrido ---\")\n        e.printStackTrace()\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>--- Mostrando la estructura final con Files.walk() ---\n    [DIR] jpg\n        [FILE] 20191101_071830.jpg\n        [FILE] 20191106_071048.jpg\n    [DIR] mp3\n        [FILE] dark-cinematic-atmosphere.mp3\n        [FILE] pad-harmonious-and-soothing-voice-like-background.mp3\n    [DIR] mp4\n        [FILE] 283533_small.mp4\n        [FILE] 293968_small.mp4\n    [DIR] pdf\n        [FILE] lorem-ipsum-1.pdf\n        [FILE] lorem-ipsum-2.pdf\n    [DIR] txt\n        [FILE] libros.txt\n        [FILE] peliculas.txt\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_directorios/#practica-2-directorios-y-comprobaciones","title":"\ud83c\udfaf Pr\u00e1ctica 2: Directorios y comprobaciones","text":"<p>Prepara la estructura de tu proyecto. Crea la ruta <code>proyecto/datos</code>. Bas\u00e1ndote en los ejemplos anteriores, desarrolla un programa en tu proyecto haga lo siguiente:</p> <ol> <li>Defina dos rutas: una para una carpeta llamada <code>datos_ini</code> y otra para una carpeta llamada <code>datos_fin</code> (ambas dentro de la carpeta <code>proyecto/datos</code> de tu proyecto).</li> <li>Comprueba los directorios: Si las carpetas no existen las deber\u00e1 crear utilizando <code>Files.createDirectories</code>.</li> <li>A\u00f1ade ficheros: A\u00f1ade (manualmente y vac\u00edo) el fichero <code>mis_datos.json</code> dentro de la carpeta <code>datos_ini</code>.</li> <li>Comprueba ficheros: Despu\u00e9s de la comprobaci\u00f3n de la existencia del fichero de datos dentro de la carpeta <code>datos_ini</code> (<code>mis_datos.json</code>) imprimir\u00e1 un mensaje por consola mostrando la estrctura de directorios y ficheros.</li> </ol> <p>La salida de tu programa debe ser parecida a esta, la primera vez que se ejecuta: <pre><code>CREACI\u00d3N DE RUTAS PROYECTO\n    Creando rutas...\n    Creaci\u00f3n de ruta para DATOS_INI\n    Creaci\u00f3n de ruta para DATOS_FIN\nMOSTRANDO ESTRUCTURA DE DIRECTORIOS Y FICHEROS\n    [DIR] datos\n        [DIR] datos_fin\n        [DIR] datos_ini\n</code></pre></p> <p>Y la segunda vez que se ejecuta, tras a\u00f1adir el fichero <code>mis_datos.json</code>: <pre><code>CREACI\u00d3N DE RUTAS PROYECTO\n    Creando rutas...\nMOSTRANDO ESTRUCTURA DE DIRECTORIOS Y FICHEROS\n    [DIR] datos\n        [DIR] datos_fin\n        [DIR] datos_ini\n            [FILE] mis_datos.json\n</code></pre></p> <p>La estructura en tu proyecto debe ser parecida a esta:</p> <p></p>"},{"location":"unidades/ud02/ficheros_intercambio/","title":"Ficheros de intercambio","text":""},{"location":"unidades/ud02/ficheros_intercambio/#4-ficheros-de-intercambio-de-informacion","title":"4. Ficheros de intercambio de informaci\u00f3n","text":"<p>Los ficheros de texto en los que la informaci\u00f3n est\u00e1 estructurada y organizada de una manera predecible permiten que distintos sistemas la lean y entiendan. Estos tipos de ficheros se utilizan en el desarrollo de software para intercambiar informaci\u00f3n entre aplicaciones y algunos de los formatos m\u00e1s importantes son CSV, JSON y XML.</p> <p>Para poder llevar a cabo este intercambio de informaci\u00f3n, hay que extraer la informaci\u00f3n del fichero origen. Este proceso no se realiza l\u00ednea por l\u00ednea, sino que el contenido del fichero se lee (parsea) utilizando la t\u00e9cnica de serializaci\u00f3n/deserializaci\u00f3n:</p> <ul> <li>Serializaci\u00f3n: Proceso de convertir un objeto en memoria (por ejemplo, una data class) en una representaci\u00f3n textual o binaria (como un String en formato JSON o XML) que se puede guardar en un fichero o enviar por red.</li> <li>Deserializaci\u00f3n: Es el proceso inverso de leer un fichero (JSON, XML, etc.) y reconstruir el objeto original en memoria para poder trabajar con \u00e9l.</li> </ul> <p>A continuaci\u00f3n se muestra una tabla con clases y herramientas que se utilizan para serializar / deserializar:</p>"},{"location":"unidades/ud02/ficheros_intercambio/#metodos-de-serializaciondeserializacion","title":"M\u00e9todos de Serializaci\u00f3n/Deserializaci\u00f3n","text":"M\u00e9todo Descripci\u00f3n <code>java.io.Serializable</code> Marca que un objeto es serializable. <code>ObjectOutputStream</code> Serializa y escribe un objeto. <code>ObjectInputStream</code> Lee un objeto serializado. <code>@transient</code> Excluye atributos de la serializaci\u00f3n. <code>ReadObject</code> Lee y reconstruye un objeto binario. <code>WriteObject</code> Guarda un objeto como binario. <code>@Serializable</code> Permite convertir el data class a JSON y viceversa."},{"location":"unidades/ud02/ficheros_intercambio/#ejemplo-serializar-y-deserializar-un-objeto-usando-transient","title":"Ejemplo - Serializar y deserializar un objeto (usando <code>@Transient</code>):","text":"<p><pre><code>import java.io.*\n// Clase Persona (serializable completamente)\nclass Persona(val nombre: String, val edad: Int) : Serializable\n// Clase Usuario con un atributo que NO se serializa\nclass Usuario(\n    val nombre: String,\n    @Transient val clave: String // Este campo no se guardar\u00e1\n) : Serializable\nfun main() {\n    val rutaPersona = \"multimedia/persona.obj\"\n    val rutaUsuario = \"multimedia/usuario.obj\"\n    // Asegurar que el directorio exista\n    val directorio = File(\"documentos\")\n    if (!directorio.exists()) {\n        directorio.mkdirs()\n    }\n    // --- Serializar Persona ---\n    val persona = Persona(\"Pol\", 30)\n    try {\n        ObjectOutputStream(FileOutputStream(rutaPersona)).use { oos -&gt;\n            oos.writeObject(persona)\n        }\n        println (\"Persona serializada.\")\n    } catch (e: IOException) {\n        println (\"Error al serializar Persona: ${e.message}\")\n    }\n    // --- Deserializar Persona ---\n    try {\n        val personaLeida = ObjectInputStream(FileInputStream(rutaPersona)).use { ois -&gt;\n            ois.readObject() as Persona\n        }\n        println (\"Persona deserializada:\")\n        println (\"Nombre: ${personaLeida.nombre}, Edad: ${personaLeida.edad}\")\n    } catch (e: Exception) {\n        println (\"Error al deserializar Persona: ${e.message}\")\n    }\n    // --- Serializar Usuario ---\n    val usuario = Usuario(\"Eli\", \"1234\")\n    try {\n        ObjectOutputStream(FileOutputStream(rutaUsuario)).use { oos -&gt;\n            oos.writeObject(usuario)\n        }\n        println (\"Usuario serializado.\")\n    } catch (e: IOException) {\n        println (\"Error al serializar Usuario: ${e.message}\")\n    }\n    // --- Deserializar Usuario ---\n    try {\n        val usuarioLeido = ObjectInputStream(FileInputStream(rutaUsuario)).use { ois -&gt;\n            ois.readObject() as Usuario\n        }\n        println (\"Usuario deserializado:\")\n        println (\"Nombre: ${usuarioLeido.nombre}, Clave: ${usuarioLeido.clave}\")\n    } catch (e: Exception) {\n        println (\"Error al deserializar Usuario: ${e.message}\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Persona serializada.\nPersona deserializada:\nNombre: Pol, Edad: 30\nUsuario serializado.\nUsuario deserializado:\nNombre: Eli, Clave: null\n</code></pre></p> <p>A continuaci\u00f3n se describen los 3 tipos de ficheros m\u00e1s comunes para intercambio de informaci\u00f3n. Se muestran ejemplos de lectura y escritura usando serializaci\u00f3n y deserializaci\u00f3n utilizando un proyecto con Gradle:</p>"},{"location":"unidades/ud02/ficheros_intercambio/#41-csv-comma-separated-values","title":"4.1. CSV (Comma-Separated Values)","text":"<p>Son ficheros de texto plano con valores separados por un delimitador (coma, punto y coma, etc.). Son \u00fatiles para exportar/importar datos desde Excel, Google Sheets, o bases de datos. Se manejan con herramientas como OpenCSV (m\u00e1s antigua) o Kotlin-CSV (la que utilizaremos).</p>"},{"location":"unidades/ud02/ficheros_intercambio/#metodos-de-kotlin-csv","title":"M\u00e9todos de Kotlin-CSV","text":"M\u00e9todo Ejemplo <code>readAll(File)</code> <code>val filas = csvReader().readAll(File(\"alumnos.csv\"))</code> <code>readAllWithHeader(File)</code> <code>val datos = csvReader().readAllWithHeader(File(\"alumnos.csv\"))</code> <code>open { readAllAsSequence() }</code> <code>csvReader().open(\"alumnos.csv\") { readAllAsSequence().forEach { println(it) } }</code> <code>writeAll(data, File)</code> <code>csvWriter().writeAll(listOf(listOf(\"Pol\", \"9\")), File(\"salida.csv\"))</code> <code>writeRow(row, File)</code> <code>csvWriter().writeRow(listOf(\"Ade\", \"8\"), File(\"salida.csv\"))</code> <code>writeAllWithHeader(data, File)</code> <code>csvWriter().writeAllWithHeader(listOf(mapOf(\"nombre\" to \"Eli\", \"nota\" to \"10\")), File(\"salida.csv\"))</code> <code>delimiter</code>, <code>quoteChar</code>, etc. <code>csvReader { delimiter = ';' }</code>"},{"location":"unidades/ud02/ficheros_intercambio/#ejemplo-de-lectura-y-escritura-de-ficheros-csv","title":"Ejemplo de lectura y escritura de ficheros CSV:","text":"<p>Partimos de un fichero llamado <code>mis_plantas.csv</code> con la informaci\u00f3n siguiente: <pre><code>1;Aloe Vera;Aloe barbadensis miller;7;0.6\n2;Lavanda;Lavandula angustifolia;3;1.0\n3;Helecho de Boston;Nephrolepis exaltata;5;0.9\n4;Bamb\u00fa de la suerte;Dracaena sanderiana;4;1.5\n5;Girasol;Helianthus annuus;2;3.0\n</code></pre> Donde los campos corresponden a: * <code>id_planta</code> (int) * <code>nombre_comun</code> (string) * <code>nombre_cientifico</code> (string) * <code>frecuencia_riego</code> (int) * <code>altura_m\u00e1xima</code> (double)</p> <p>Utilizaremos la librer\u00eda Kotlin-CSV. Por tanto habr\u00e1 que indicarlo en el fichero <code>build.gradle.kts</code> a\u00f1adiendo las siguientes l\u00edneas:</p> <ul> <li>En <code>plugins</code>: <pre><code>kotlin(\"plugin.serialization\") version \"1.9.0\"\n</code></pre></li> <li>En <code>dependencies</code>: <pre><code>implementation(\"com.github.doyaaaaaken:kotlin-csv-jvm:1.9.1\")\n</code></pre></li> </ul> <p><pre><code>import java.nio.file.Files\nimport java.nio.file.Path\nimport java.io.File\n// Librer\u00eda espec\u00edfica de Kotlin para leer y escribir ficheros CSV.\nimport com.github.doyaaaaaken.kotlincsv.dsl.csvReader\nimport com.github.doyaaaaaken.kotlincsv.dsl.csvWriter\n//Usamos una 'data class' para representar la estructura de una planta.\ndata class Planta(val id_planta: Int, val nombre_comun: String, val nombre_cientifico: String, val riego: Int, val altura: Double)\nfun main() {\n    val entradaCSV = Path.of(\"datos_ini/mis_plantas.csv\")\n    val salidaCSV = Path.of(\"datos_ini/mis_plantas2.csv\")\n    val datos: List&lt;Planta&gt;\n    datos = leerDatosInicialesCSV(entradaCSV)\n    for (dato in datos) {\n        println (\"  - ID: ${dato.id_planta}, Nombre com\u00fan: ${dato.nombre_comun}, Nombre cient\u00edfico: ${dato.nombre_cientifico}, Frecuencia de riego: ${dato.riego} d\u00edas, Altura: ${dato.altura} metros\")\n    }\n    escribirDatosCSV(salidaCSV, datos)\n}\nfun leerDatosInicialesCSV(ruta: Path): List&lt;Planta&gt; {\n    var plantas: List&lt;Planta&gt; = emptyList()\n    // Comprobar si el fichero es legible antes de intentar procesarlo.\n    if (!Files.isReadable(ruta)) {\n        println (\"Error: No se puede leer el fichero en la ruta: $ruta\")\n    } else {\n        // Configuramos el lector de CSV con el delimitador\n        val reader = csvReader {\n            delimiter = ';'\n        }\n        /* Leemos TODO el fichero CSV.\n        El resultado es una lista de listas de Strings (`List&lt;List&lt;String&gt;&gt;`),\n        donde cada lista interna representa una fila del fichero.*/\n        val filas: List&lt;List&lt;String&gt;&gt; = reader.readAll(ruta.toFile())\n        /* Convertir la lista de texto plano en una lista de objetos 'Planta'.\n        `mapNotNull` funciona como un `map` y descartando todos los `null` de la lista final.\n        Si una fila del CSV es inv\u00e1lida, devolvemos `null`\n        y `mapNotNull` se encarga de ignorarla. */\n        plantas = filas.mapNotNull { columnas -&gt;\n            // Validar si La fila tiene al menos 4 columnas.\n            if (columnas.size &gt;= 5) {\n                try {\n                    val id_planta = columnas[0].toInt()\n                    val nombre_comun = columnas[1]\n                    val nombre_cientifico = columnas[2]\n                    val riego = columnas[3].toInt()\n                    val altura = columnas[4].toDouble()\n                    Planta(id_planta,nombre_comun, nombre_cientifico, riego, altura) //crear el objeto Planta\n                } catch (e: Exception) {\n                    /* Si ocurre un error en la conversi\u00f3n (ej: NumberFormatException),\n                    capturamos la excepci\u00f3n, imprimimos un aviso (opcional)\n                    y devolvemos `null` para que `mapNotNull` descarte esta fila. */\n                    println (\"Fila inv\u00e1lida ignorada: $columnas -&gt; Error: ${e.message}\")\n                    null\n                }\n            } else {\n                // Si la fila no tiene suficientes columnas, es inv\u00e1lida. Devolvemos null.\n                println (\"Fila con formato incorrecto ignorada: $columnas\")\n                null\n            }\n        }\n    }\n    return plantas\n}\nfun escribirDatosCSV(ruta: Path,plantas: List&lt;Planta&gt;){\n    try {\n        val fichero: File = ruta.toFile()\n        csvWriter {\n            delimiter = ';'\n        }.writeAll(\n            plantas.map { planta -&gt;\n                listOf (planta.id_planta.toString(),\n                    planta.nombre_comun,\n                    planta.nombre_cientifico,\n                    planta.riego.toString(),\n                    planta.altura.toString())\n            } ,\n            fichero\n        )\n        println (\"\\nInformaci\u00f3n guardada en: $fichero\")\n    } catch (e: Exception) {\n        println (\"Error: ${e.message}\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior, comprueba que la salida es la siguiente, que se ha creado el fichero <code>mis_plantas2.csv</code> y que su contenido es correcto: <pre><code>  - ID: 1, Nombre com\u00fan: Aloe Vera, Nombre cient\u00edfico: Aloe barbadensis miller, Frecuencia de riego: 7 d\u00edas, Altura: 0.6 metros\n  - ID: 2, Nombre com\u00fan: Lavanda, Nombre cient\u00edfico: Lavandula angustifolia, Frecuencia de riego: 3 d\u00edas, Altura: 1.0 metros\n  - ID: 3, Nombre com\u00fan: Helecho de Boston, Nombre cient\u00edfico: Nephrolepis exaltata, Frecuencia de riego: 5 d\u00edas, Altura: 0.9 metros\n  - ID: 4, Nombre com\u00fan: Bamb\u00fa de la suerte, Nombre cient\u00edfico: Dracaena sanderiana, Frecuencia de riego: 4 d\u00edas, Altura: 1.5 metros\n  - ID: 5, Nombre com\u00fan: Girasol, Nombre cient\u00edfico: Helianthus annuus, Frecuencia de riego: 2 d\u00edas, Altura: 3.0 metros\n\nInformaci\u00f3n guardada en: datos_ini\\mis_plantas2.csv\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_intercambio/#42-xml-extensible-markup-language","title":"4.2. XML (eXtensible Markup Language)","text":"<p>Los ficheros XML son muy estructurados y extensibles. Se basan en etiquetas anidadas similar a HTML. Permiten la validaci\u00f3n de datos (mediante esquemas XSD) y es ideal para integraci\u00f3n con sistemas empresariales (legacy). Se manejan con librer\u00edas como JAXB, DOM, JDOM2 o Jackson XML (XmlMapper) que es la que utilizaremos.</p>"},{"location":"unidades/ud02/ficheros_intercambio/#metodos-de-jackson-xml","title":"M\u00e9todos de Jackson XML","text":"M\u00e9todo Descripci\u00f3n <code>readValue(File, Class&lt;T&gt;)</code> Lee un fichero XML y lo convierte en un objeto Kotlin/Java. <code>readValue(String, Class&lt;T&gt;)</code> Lee un String XML y lo convierte en un objeto. <code>writeValue(File, Object)</code> Escribe un objeto como XML en un fichero. <code>writeValueAsString(Object)</code> Convierte un objeto en una cadena XML. <code>writeValueAsBytes(Object)</code> Convierte un objeto en un array de bytes XML. <code>registerModule(Module)</code> Registra un m\u00f3dulo como <code>KotlinModule</code> o <code>JavaTimeModule</code>. <code>enable(SerializationFeature)</code> Activa una opci\u00f3n de serializaci\u00f3n (por ejemplo, indentado). <code>disable(DeserializationFeature)</code> Desactiva una opci\u00f3n de deserializaci\u00f3n. <code>configure(MapperFeature, boolean)</code> Configura opciones generales del mapeo. <code>setDefaultPrettyPrinter(...)</code> Establece un formateador personalizado."},{"location":"unidades/ud02/ficheros_intercambio/#ejemplo-de-lectura-y-escritura-de-ficheros-xml","title":"Ejemplo de lectura y escritura de ficheros XML:","text":"<p>Partimos de un fichero llamado <code>mis_plantas.xml</code> con la informaci\u00f3n siguiente: <pre><code>&lt;plantas&gt;\n  &lt;planta&gt;\n    &lt;id_planta&gt;1&lt;/id_planta&gt;\n    &lt;nombre_comun&gt;Aloe Vera&lt;/nombre_comun&gt;\n    &lt;nombre_cientifico&gt;Aloe barbadensis miller&lt;/nombre_cientifico&gt;\n    &lt;frecuencia_riego&gt;7&lt;/frecuencia_riego&gt;\n    &lt;altura_maxima&gt;0.6&lt;/altura_maxima&gt;\n  &lt;/planta&gt;\n  &lt;planta&gt;\n    &lt;id_planta&gt;2&lt;/id_planta&gt;\n    &lt;nombre_comun&gt;Lavanda&lt;/nombre_comun&gt;\n    &lt;nombre_cientifico&gt;Lavandula angustifolia&lt;/nombre_cientifico&gt;\n    &lt;frecuencia_riego&gt;3&lt;/frecuencia_riego&gt;\n    &lt;altura_maxima&gt;1.0&lt;/altura_maxima&gt;\n  &lt;/planta&gt;\n  &lt;planta&gt;\n    &lt;id_planta&gt;3&lt;/id_planta&gt;\n    &lt;nombre_comun&gt;Helecho de Boston&lt;/nombre_comun&gt;\n    &lt;nombre_cientifico&gt;Nephrolepis exaltata&lt;/nombre_cientifico&gt;\n    &lt;frecuencia_riego&gt;5&lt;/frecuencia_riego&gt;\n    &lt;altura_maxima&gt;0.9&lt;/altura_maxima&gt;\n  &lt;/planta&gt;\n  &lt;planta&gt;\n    &lt;id_planta&gt;4&lt;/id_planta&gt;\n    &lt;nombre_comun&gt;Bamb\u00fa de la suerte&lt;/nombre_comun&gt;\n    &lt;nombre_cientifico&gt;Dracaena sanderiana&lt;/nombre_cientifico&gt;\n    &lt;frecuencia_riego&gt;4&lt;/frecuencia_riego&gt;\n    &lt;altura_maxima&gt;1.5&lt;/altura_maxima&gt;\n  &lt;/planta&gt;\n  &lt;planta&gt;\n    &lt;id_planta&gt;5&lt;/id_planta&gt;\n    &lt;nombre_comun&gt;Girasol&lt;/nombre_comun&gt;\n    &lt;nombre_cientifico&gt;Helianthus annuus&lt;/nombre_cientifico&gt;\n    &lt;frecuencia_riego&gt;2&lt;/frecuencia_riego&gt;\n    &lt;altura_maxima&gt;3.0&lt;/altura_maxima&gt;\n  &lt;/planta&gt;\n&lt;/plantas&gt;\n</code></pre> Utilizaremos la librer\u00eda Jackson XML. Por tanto habr\u00e1 que indicarlo en el fichero <code>build.gradle.kts</code> a\u00f1adiendo las siguientes l\u00edneas: <pre><code>implementation (\"com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.17.0\")\nimplementation (\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.0\")\n</code></pre></p> <p><pre><code>import java.nio.file.Path\nimport java.io.File\n// Anotaciones y clases de la librer\u00eda Jackson para el mapeo a XML.\nimport com.fasterxml.jackson.dataformat.xml.XmlMapper\nimport com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement\nimport com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper\nimport com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty\nimport com.fasterxml.jackson.module.kotlin.readValue\nimport com.fasterxml.jackson.module.kotlin.registerKotlinModule\n/*Representa la estructura de una \u00fanica planta. La propiedad 'id_planta' ser\u00e1 la etiqueta &lt;id_planta&gt;...&lt;/id_planta&gt; (as\u00ed todas) */\ndata class Planta(\n    @JacksonXmlProperty(localName = \"id_planta\")\n    val id_planta: Int,\n    @JacksonXmlProperty(localName = \"nombre_comun\")\n    val nombre_comun: String,\n    @JacksonXmlProperty(localName = \"nombre_cientifico\")\n    val nombre_cientifico: String,\n    @JacksonXmlProperty(localName = \"frecuencia_riego\")\n    val frecuencia_riego: Int,\n    @JacksonXmlProperty(localName = \"altura_maxima\")\n    val altura_maxima: Double\n)\n//nombre del elemento ra\u00edz\n@JacksonXmlRootElement(localName = \"plantas\")\n// Data class que representa el elemento ra\u00edz del XML.\ndata class Plantas(\n    @JacksonXmlElementWrapper(useWrapping = false) // No necesitamos la etiqueta &lt;plantas&gt; aqu\u00ed\n    @JacksonXmlProperty(localName = \"planta\")\n    val listaPlantas: List&lt;Planta&gt; = emptyList()\n)\nfun main() {\n    val entradaXML = Path.of(\"datos_ini/mis_plantas.xml\")\n    val salidaXML = Path.of(\"datos_ini/mis_plantas2.xml\")\n    val datos: List&lt;Planta&gt;\n    datos = leerDatosInicialesXML(entradaXML)\n    for (dato in datos) {\n        println (\"  - ID: ${dato.id_planta}, Nombre com\u00fan: ${dato.nombre_comun}, Nombre cient\u00edfico: ${dato.nombre_cientifico}, Frecuencia de riego: ${dato.frecuencia_riego} d\u00edas, Altura: ${dato.altura_maxima} metros\")\n    }\n    escribirDatosXML(salidaXML, datos)\n}\nfun leerDatosInicialesXML(ruta: Path): List&lt;Planta&gt; {\n    val fichero: File = ruta.toFile()\n    // Deserializar el XML a objetos Kotlin\n    val xmlMapper = XmlMapper().registerKotlinModule()\n    // 'readValue' convierte el contenido XML en una instancia de la clase 'Plantas'\n    val plantasWrapper: Plantas = xmlMapper.readValue(fichero)\n    return plantasWrapper.listaPlantas\n}\nfun escribirDatosXML(ruta: Path,plantas: List&lt;Planta&gt;) {\n    try {\n        val fichero: File = ruta.toFile()\n        // Creamos instancia de la clase 'Plantas' (ra\u00edz del XML).\n        val contenedorXml = Plantas(plantas)\n        // Configuramos el 'XmlMapper' (motor de Jackson) para la conversi\u00f3n a XML.\n        val xmlMapper = XmlMapper().registerKotlinModule()\n        // Convertimos 'contenedorXml' en un String con formato XML.\n        // .writerWithDefaultPrettyPrinter() formatea con indentaci\u00f3n y saltos de l\u00ednea\n        val xmlString = xmlMapper.writerWithDefaultPrettyPrinter().writeValueAsString(contenedorXml)\n        // escribir un String en un fichero con 'writeText'\n        fichero.writeText(xmlString)\n        println (\"\\nInformaci\u00f3n guardada en: $fichero\")\n    } catch (e: Exception) {\n        println (\"Error: ${e.message}\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior, comprueba que la salida es la siguiente, que se ha creado el fichero <code>mis_plantas2.xml</code> y que su contenido es correcto: <pre><code>  - ID: 1, Nombre com\u00fan: Aloe Vera, Nombre cient\u00edfico: Aloe barbadensis miller, Frecuencia de riego: 7 d\u00edas, Altura: 0.6 metros\n  - ID: 2, Nombre com\u00fan: Lavanda, Nombre cient\u00edfico: Lavandula angustifolia, Frecuencia de riego: 3 d\u00edas, Altura: 1.0 metros\n  - ID: 3, Nombre com\u00fan: Helecho de Boston, Nombre cient\u00edfico: Nephrolepis exaltata, Frecuencia de riego: 5 d\u00edas, Altura: 0.9 metros\n  - ID: 4, Nombre com\u00fan: Bamb\u00fa de la suerte, Nombre cient\u00edfico: Dracaena sanderiana, Frecuencia de riego: 4 d\u00edas, Altura: 1.5 metros\n  - ID: 5, Nombre com\u00fan: Girasol, Nombre cient\u00edfico: Helianthus annuus, Frecuencia de riego: 2 d\u00edas, Altura: 3.0 metros\n\nInformaci\u00f3n guardada en: datos_ini\\mis_plantas2.xml\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_intercambio/#43-json-javascript-object-notation","title":"4.3. JSON (JavaScript Object Notation)","text":"<p>Son ficheros ligeros, f\u00e1ciles de leer y con una estructura de pares clave-valor y listas. Ideales para APIs REST, ficheros de configuraci\u00f3n y bases de datos NoSQL (como MongoDB). Se maneja con librer\u00edas como Jackson &amp; Gson (Java) o kotlinx.serialization (la que utilizaremos en Kotlin).</p>"},{"location":"unidades/ud02/ficheros_intercambio/#metodos-de-kotlinxserialization","title":"M\u00e9todos de kotlinx.serialization","text":"M\u00e9todo / Ejemplo Descripci\u00f3n <code>Json.encodeToString(objeto)</code> <code>Json.encodeToString(persona)</code> <code>Json.encodeToString(serializer, obj)</code> <code>Json.encodeToString(Persona.serializer(), persona)</code> <code>Json.decodeFromString(json)</code> <code>Json.decodeFromString&lt;Persona&gt;(json)</code> <code>Json.decodeFromString(serializer, s)</code> <code>Json.decodeFromString(Persona.serializer(), json)</code> <code>Json.encodeToJsonElement(objeto)</code> <code>val elem = Json.encodeToJsonElement(persona)</code> <code>Json.decodeFromJsonElement(elem)</code> <code>val persona = Json.decodeFromJsonElement&lt;Persona&gt;(elem)</code> <code>Json.parseToJsonElement(string)</code> <code>val elem = Json</code>"},{"location":"unidades/ud02/ficheros_intercambio/#ejemplo-de-lectura-y-escritura-de-ficheros-json","title":"Ejemplo de lectura y escritura de ficheros JSON:","text":"<p>Partimos de un fichero llamado <code>mis_plantas.json</code> con la informaci\u00f3n siguiente: <pre><code>[\n  {\n    \"id_planta\": 1,\n    \"nombre_comun\": \"Aloe Vera\",\n    \"nombre_cientifico\": \"Aloe barbadensis miller\",\n    \"frecuencia_riego\": 7,\n    \"altura_maxima\": 0.6\n  },\n  {\n    \"id_planta\": 2,\n    \"nombre_comun\": \"Lavanda\",\n    \"nombre_cientifico\": \"Lavandula angustifolia\",\n    \"frecuencia_riego\": 3,\n    \"altura_maxima\": 1.0\n  },\n  {\n    \"id_planta\": 3,\n    \"nombre_comun\": \"Helecho de Boston\",\n    \"nombre_cientifico\": \"Nephrolepis exaltata\",\n    \"frecuencia_riego\": 5,\n    \"altura_maxima\": 0.9\n  },\n  {\n    \"id_planta\": 4,\n    \"nombre_comun\": \"Bamb\u00fa de la suerte\",\n    \"nombre_cientifico\": \"Dracaena sanderiana\",\n    \"frecuencia_riego\": 4,\n    \"altura_maxima\": 1.5\n  },\n  {\n    \"id_planta\": 5,\n    \"nombre_comun\": \"Girasol\",\n    \"nombre_cientifico\": \"Helianthus annuus\",\n    \"frecuencia_riego\": 2,\n    \"altura_maxima\": 3.0\n  }\n]\n</code></pre> Utilizaremos la librer\u00eda kotlinx.serialization. Por tanto habr\u00e1 que indicarlo en el fichero <code>build.gradle.kts</code> a\u00f1adiendo las siguientes l\u00edneas:</p> <ul> <li>En <code>plugins</code>: <pre><code>kotlin(\"plugin.serialization\") version \"1.9.0\"\n</code></pre></li> <li>En <code>dependencies</code>: <pre><code>implementation (\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0\")\n</code></pre></li> </ul> <p>Llamaremos a <code>Json.encodeToString()</code> para serializar una instancia de esta clase y a <code>Json.decodeFromString()</code> para deserializarla.</p> <p><pre><code>import java.nio.file.Files\nimport java.nio.file.Path\nimport java.io.File\n// Clases de la librer\u00eda oficial de Kotlin para la serializaci\u00f3n/deserializaci\u00f3n.\nimport kotlinx.serialization.*\nimport kotlinx.serialization.json.*\n//Usamos una 'data class' para representar la estructura de una planta e indicamos que es serializable\n@Serializable\ndata class Planta(val id_planta: Int, val nombre_comun: String, val nombre_cientifico: String, val frecuencia_riego: Int, val altura_maxima: Double)\nfun main() {\n    val entradaJSON = Path.of(\"datos_ini/mis_plantas.json\")\n    val salidaJSON = Path.of(\"datos_ini/mis_plantas2.json\")\n    val datos: List&lt;Planta&gt;\n    datos = leerDatosInicialesJSON(entradaJSON)\n    for (dato in datos) {\n        println (\"  - ID: ${dato.id_planta}, Nombre com\u00fan: ${dato.nombre_comun}, Nombre cient\u00edfico: ${dato.nombre_cientifico}, Frecuencia de riego: ${dato.frecuencia_riego} d\u00edas, Altura: ${dato.altura_maxima} metros\")\n    }\n    escribirDatosJSON(salidaJSON, datos)\n}\nfun leerDatosInicialesJSON(ruta: Path): List&lt;Planta&gt; {\n    var plantas: List&lt;Planta&gt; = emptyList()\n    val jsonString = Files.readString(ruta)\n    /* A `Json.decodeFromString` le pasamos el String con el JSON.\n    Con `&lt;List&lt;Planta&gt;&gt;`, le indicamos que debe interpretarlo como\n    una lista de objetos de tipo planta\".\n    La librer\u00eda usar\u00e1 la anotaci\u00f3n @Serializable de la clase Planta para saber c\u00f3mo mapear los campos del JSON (\"id_planta\", \"nombre_comun\", etc.)\n    a las propiedades del objeto. */\n    plantas = Json.decodeFromString&lt;List&lt;Planta&gt;&gt;(jsonString)\n    return plantas\n}\nfun escribirDatosJSON(ruta: Path,plantas: List&lt;Planta&gt;) {\n    try {\n        /* La librer\u00eda `kotlinx.serialization`\n        toma la lista de objetos `Planta` (`List&lt;Planta&gt;`) y la convierte en una\n        \u00fanica cadena de texto con formato JSON.\n        `prettyPrint` formatea el JSON para que sea legible. */\n        val json = Json { prettyPrint = true }.encodeToString(plantas)\n        // Con `Files.writeString` escribimos el String JSON en el fichero de salida\n        Files.writeString(ruta, json)\n        println (\"\\nInformaci\u00f3n guardada en: $ruta\")\n    } catch (e: Exception) {\n        println (\"Error: ${e.message}\")\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior, comprueba que la salida es la siguiente, que se ha creado el fichero <code>mis_plantas2.json</code> y que su contenido es correcto: <pre><code>  - ID: 1, Nombre com\u00fan: Aloe Vera, Nombre cient\u00edfico: Aloe barbadensis miller, Frecuencia de riego: 7 d\u00edas, Altura: 0.6 metros\n  - ID: 2, Nombre com\u00fan: Lavanda, Nombre cient\u00edfico: Lavandula angustifolia, Frecuencia de riego: 3 d\u00edas, Altura: 1.0 metros\n  - ID: 3, Nombre com\u00fan: Helecho de Boston, Nombre cient\u00edfico: Nephrolepis exaltata, Frecuencia de riego: 5 d\u00edas, Altura: 0.9 metros\n  - ID: 4, Nombre com\u00fan: Bamb\u00fa de la suerte, Nombre cient\u00edfico: Dracaena sanderiana, Frecuencia de riego: 4 d\u00edas, Altura: 1.5 metros\n  - ID: 5, Nombre com\u00fan: Girasol, Nombre cient\u00edfico: Helianthus annuus, Frecuencia de riego: 2 d\u00edas, Altura: 3.0 metros\n\nInformaci\u00f3n guardada en: datos_ini\\mis_plantas2.json\n</code></pre></p>"},{"location":"unidades/ud02/ficheros_intercambio/#44-conversiones-entre-ficheros","title":"4.4. Conversiones entre ficheros","text":"<p>Una vez vistas las caracter\u00edsticas de los ficheros de intercambio de informaci\u00f3n m\u00e1s comunes podemos llegar a la conclusi\u00f3n que en programaci\u00f3n y gesti\u00f3n de datos, no todos los formatos sirven igual para todos los casos. Convertir entre CSV, JSON y XML permite aprovechar las ventajas de cada uno.</p> <p>El patr\u00f3n para convertir datos de un formato a otro es casi siempre el mismo. En lugar de intentar una conversi\u00f3n directa, utilizamos nuestras clases de Kotlin (<code>data class</code>) como un paso intermedio universal:</p> <p>Formato Origen \u2192 Objetos Kotlin en Memoria \u2192 Formato Destino</p> <p>\ud83d\udd0d Realiza algunas conversiones entre ficheros CSV, JSON y XML para practicar la lectura / escritura y la serializaci\u00f3n / deserializaci\u00f3n. Puedes reutilizar el c\u00f3digo de los ejemplos.</p>"},{"location":"unidades/ud02/ficheros_intercambio/#practica-3-creacion-y-lectura-de-un-fichero-de-datos","title":"\ud83c\udfaf Pr\u00e1ctica 3: Creaci\u00f3n y lectura de un fichero de datos","text":"<p>Realiza lo siguiente:</p> <ul> <li>Dise\u00f1a tu data class: Define la <code>data class</code> de Kotlin que represente un \u00fanico elemento de tu colecci\u00f3n de datos. Debe tener un ID \u00fanico de tipo <code>Int</code>, un nombre de tipo <code>String</code> y, al menos, otros dos campos (al menos uno de tipo <code>Double</code>).</li> <li>Crea tu fichero de datos: (.csv, .json o .xml) con al menos 5 registros de tu colecci\u00f3n dentro de la carpeta <code>datos_ini</code>.</li> <li>A\u00f1ade dependencias necesarias: A\u00f1ade las librer\u00edas necesarias para leer tu fichero y serializar / deserializar datos en <code>build.gradle.kts</code>.</li> <li>Crea la funci\u00f3n de lectura: La funci\u00f3n debe leer el fichero de texto y devolver una lista de objetos <code>leerDatosIniciales(): List&lt;DataClass&gt;</code>.</li> <li>Verifica que funciona: Imprime por consola la informaci\u00f3n le\u00edda.</li> <li>Aspectos T\u00e9cnicos Obligatorios:<ul> <li>Se debe incluir un manejo b\u00e1sico de errores (ej: comprobar si el fichero existe antes de leerlo, try-catch para conversiones num\u00e9ricas, etc.).</li> </ul> </li> </ul>"},{"location":"unidades/ud02/ficheros_intercambio/#entrega-parcial","title":"\ud83d\udcc1 Entrega parcial","text":"<p>Entrega el c\u00f3digo fuente del proyecto comprimido en un fichero <code>.zip</code> para que el profesor te d\u00e9 sugerencias de mejora (el programa entregado deber\u00e1 ejecutarse, si da error de ejecuci\u00f3n, no se podr\u00e1 revisar).</p>"},{"location":"unidades/ud02/ficheros_texto/","title":"Ficheros de texto","text":""},{"location":"unidades/ud02/ficheros_texto/#3-ficheros-de-texto","title":"3. Ficheros de texto","text":"<p>Los ficheros de texto son legibles directamente por humanos y son una buena opci\u00f3n para guardar informaci\u00f3n despu\u00e9s de cerrar el programa. A continuaci\u00f3n se muestran algunas clases y m\u00e9todos para leer y escribir informaci\u00f3n en ellos:</p>"},{"location":"unidades/ud02/ficheros_texto/#metodos-de-ficheros-de-texto","title":"M\u00e9todos de Ficheros de Texto","text":"M\u00e9todo Descripci\u00f3n <code>Files.readAllLines(path)</code> devuelve <code>List&lt;String&gt;</code> Leer ficheros. <code>Files.exists(path)</code> Verificar existencia. <code>split()</code>, <code>trim()</code>, <code>toIntOrNull()</code> Procesar texto. <code>Files.write(path, lines)</code> Escribe una lista de l\u00edneas (<code>List&lt;String&gt;</code>) a un fichero. <code>StandardOpenOption.READ</code> Abrir un fichero en modo lectura. <code>StandardOpenOption.WRITE</code> Abrir un fichero en modo escritura. <code>StandardOpenOption.APPEND</code> Agrega contenido al final del fichero sin borrar lo anterior. <code>StandardOpenOption.CREATE</code> Si no existe, lo crea. <code>StandardOpenOption.TRUNCATE_EXISTING</code> Si existe, borra lo anterior. <code>Files.newBufferedReader(Path)</code>, <code>Files.newBufferedWriter(Path)</code> M\u00e1s eficiente para ficheros grandes. <code>Files.readString(Path)</code> (Java 11+), <code>Files.writeString(Path, String)</code> Lectura/escritura completa como bloque. <p>Dentro de los ficheros de texto existen ficheros de texto plano (sin ning\u00fan tipo de estructura) y ficheros de texto en los que la informaci\u00f3n est\u00e1 estructurada.</p>"},{"location":"unidades/ud02/ficheros_texto/#ejemplo-escritura-y-lectura-en-fichero-de-texto-plano-txt","title":"Ejemplo - Escritura y lectura en fichero de texto plano .txt:","text":"<p><pre><code>import java.nio.file.Files\nimport java.nio.file.Paths\nimport java.nio.charset.StandardCharsets\nfun main() {\n    //Escritura en fichero de texto\n    //writeString\n    val texto = \"Hola, mundo desde Kotlin\"\n    Files.writeString(Paths.get(\"documentos/saludo.txt\"), texto)\n    //write\n    val ruta = Paths.get(\"documentos/texto.txt\")\n    val lineasParaGuardar = listOf(\n        \"Primera l\u00ednea\",\n        \"Segunda l\u00ednea\",\n        \"\u00a1Hola desde Kotlin!\"\n    )\n    Files.write(ruta, lineasParaGuardar, StandardCharsets.UTF_8)\n    println (\"Fichero de texto escrito.\")\n    //newBuffered\n    Files.newBufferedWriter(Paths.get(\"documentos/log.txt\")).use { writer -&gt;\n        writer.write(\"Log iniciado...\\n\")\n        writer.write(\"Proceso completado.\\n\")\n    }\n    //Lectura del fichero de texto\n    //readAllLines\n    val lineasLeidas = Files.readAllLines(ruta)\n    println (\"Contenido le\u00eddo con readAllLines:\")\n    for (lineas in lineasLeidas) {\n        println (lineas)\n    }\n    //readString\n    val contenido = Files.readString(ruta)\n    println (\"Contenido le\u00eddo con readString:\")\n    println (contenido)\n    //newBufferedReader\n    Files.newBufferedReader(ruta).use { reader -&gt;\n        println (\"Contenido le\u00eddo con newBufferedReader:\")\n        reader.lineSequence().forEach { println (it) }\n    }\n}\n</code></pre> \ud83d\udd0d Ejecuta el ejemplo anterior y comprueba que la salida es la siguiente: <pre><code>Fichero de texto escrito.\nContenido le\u00eddo con readAllLines:\nPrimera l\u00ednea\nSegunda l\u00ednea\n\u00a1Hola desde Kotlin!\nContenido le\u00eddo con readString:\nPrimera l\u00ednea\nSegunda l\u00ednea\n\u00a1Hola desde Kotlin!\n\nContenido le\u00eddo con newBufferedReader:\nPrimera l\u00ednea\nSegunda l\u00ednea\n\u00a1Hola desde Kotlin!\n</code></pre></p>"},{"location":"unidades/ud02/introduccion/","title":"UD2 - Persistencia en ficheros","text":""},{"location":"unidades/ud02/introduccion/#resumen","title":"Resumen","text":"<p>En este documento se recogen los contenidos referentes al RA1 (desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en ficheros identificando el campo de aplicaci\u00f3n de los mismos y utilizando clases espec\u00edficas).</p>"},{"location":"unidades/ud02/introduccion/#guia-de-uso","title":"Gu\u00eda de uso","text":"<p>Estos apuntes est\u00e1n dise\u00f1ados para que aprendas haciendo. A lo largo de la unidad, no solo veremos la teor\u00eda, sino que la aplicaremos directamente para construir, paso a paso, una aplicaci\u00f3n completa de gesti\u00f3n de datos. El tema de la aplicaci\u00f3n lo eliges t\u00fa, pero los pasos que daremos ser\u00e1n los mismos para todos. Siguiendo la unidad no solo habr\u00e1s aprendido los conceptos, sino que tendr\u00e1s una aplicaci\u00f3n completa y funcional creada por ti.</p> <p>Intercaladas con la teor\u00eda y con los ejemplos encontrar\u00e1s tres tipos de cajas:</p> <ul> <li>\ud83d\udd0d Ejecutar y analizar: \"Estas cajas son para analizar y comprender en detalle el ejemplo de c\u00f3digo proporcionado. Tu tarea es ejecutar ese c\u00f3digo, observar la salida y asegurarte de entender c\u00f3mo y por qu\u00e9 funciona.\"</li> <li>\ud83c\udfaf Pr\u00e1ctica para aplicar y construir: \"Estas cajas son pr\u00e1cticas que debes realizar t\u00fa. Es el momento de ponerte a programar y aplicar lo que acabas de aprender. Son los objetivos que debes completar para avanzar. Cada una de estas pr\u00e1cticas es un bloque que debes programar para ir avanzando en tu proyecto final. En cada pr\u00e1ctica ampliar\u00e1s lo de las anteriores.\"</li> <li>\ud83d\udcc1 Entrega: \"Estas cajas son entregas de tu trabajo. Las entregas pueden ser parciales (el profesor te dar\u00e1 sugerencias de mejora) o finales (el profesor calificar\u00e1 el trabajo que has realizado). No todas las pr\u00e1cticas llevan asociada una entrega.\"</li> </ul>"},{"location":"unidades/ud02/introduccion/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Un fichero o archivo es una unidad de almacenamiento de datos en un sistema inform\u00e1tico. Es un conjunto de informaci\u00f3n (secuencia de bytes) organizada y almacenada en un dispositivo de almacenamiento (disco duro, memoria USB o un servidor en la nube). Los datos guardados en ficheros persisten m\u00e1s all\u00e1 de la ejecuci\u00f3n de la aplicaci\u00f3n que los trata. La utilizaci\u00f3n de ficheros es una alternativa sencilla y eficiente a las bases de datos.</p>"},{"location":"unidades/ud02/introduccion/#caracteristicas-de-un-fichero","title":"Caracter\u00edsticas de un fichero:","text":"<ul> <li>Nombre: Cada fichero tiene un nombre \u00fanico dentro de su directorio.</li> <li>Extensi\u00f3n: Indica su tipo (.txt para texto, .jpg para im\u00e1genes, etc).</li> <li>Ubicaci\u00f3n: Directorios (carpetas) dentro del sistema de ficheros.</li> <li>Contenido: Texto, im\u00e1genes, v\u00eddeos, c\u00f3digo fuente, bases de datos, etc.</li> <li>Permisos de acceso: Se pueden configurar para permitir o restringir la lectura, escritura o ejecuci\u00f3n a determinados usuarios o programas.</li> </ul>"},{"location":"unidades/ud02/introduccion/#tipos-de-ficheros","title":"Tipos de ficheros:","text":"<ul> <li>De texto: Formato legible por humanos (.txt, .csv, .json, .xml).</li> <li>Binarios: Formato no legible directamente (.exe, .jpg, .mp3, .dat).</li> <li>De c\u00f3digo fuente: Contienen instrucciones escritas en lenguajes de programaci\u00f3n (.java, .kt, .py).</li> <li>De configuraci\u00f3n: Almacenan par\u00e1metros de configuraci\u00f3n de programas (.ini, .conf, .properties, .json).</li> <li>De bases de datos: Se utilizan para almacenar grandes vol\u00famenes de datos estructurados (.db, .sql).</li> <li>Historial: de eventos o errores en un sistema (.log).</li> </ul>"},{"location":"unidades/ud02/introduccion/#api-para-manejo-de-ficheros","title":"API para manejo de ficheros:","text":"<p>Java.nio (New IO) es una API disponible desde la versi\u00f3n 7 de Java que permite mejorar el rendimiento, as\u00ed como simplificar el manejo de muchas operaciones. Funciona a trav\u00e9s de interfaces y clases para que la m\u00e1quina virtual Java tenga acceso a ficheros, atributos de ficheros y sistemas de ficheros. En los siguientes apartados veremos c\u00f3mo trabajar con ella.</p>"},{"location":"unidades/ud02/introduccion/#formas-de-acceso","title":"Formas de acceso:","text":"<p>El acceso a ficheros es una tarea fundamental en la programaci\u00f3n, ya que permite leer y escribir datos persistentes. Hemos visto que hay diferentes tipos de ficheros, seg\u00fan sus caracter\u00edsticas y necesidades existen dos formas principales de acceder a un fichero (secuencial y aleatorio):</p> <ul> <li>Acceso secuencial: Los datos se procesan en orden, desde el principio hasta el final del fichero. Es el m\u00e1s com\u00fan y sencillo. Se usa cuando se desea leer todo el contenido o recorrer registro por registro. Por ejemplo lectura de un fichero de texto l\u00ednea por l\u00ednea, o de un fichero binario estructurado registro a registro.</li> </ul> <p></p> <ul> <li>Acceso aleatorio: Permite saltar a una posici\u00f3n concreta del fichero sin necesidad de leer lo anterior. Es \u00fatil cuando los registros tienen un tama\u00f1o fijo y se necesita eficiencia (por ejemplo, ir directamente al registro 100). Requiere t\u00e9cnicas m\u00e1s avanzadas como el uso de <code>FileChannel</code>, <code>SeekableByteChannel</code> o <code>RandomAccessFile</code>.</li> </ul> <p></p> <p>A lo largo de esta unidad se explicar\u00e1n algunas funciones de manejo de ficheros que requieren librer\u00edas externas (dependencias). Utilizaremos Gradle para descargarlas autom\u00e1ticamente en nuestros proyectos.</p> <p>Para crear un proyecto Kotlin con Gradle en IntelliJ haremos clic en New Project, indicamos la informaci\u00f3n de la siguiente imagen, haremos clic en el bot\u00f3n Create y esperaremos a que IntelliJ prepare el proyecto.</p> <p></p> <p>A medida que necesitemos utilizar dependencias en nuestro proyecto, las iremos a\u00f1adiendo al fichero build.gradle.kts en la secci\u00f3n de dependencias. Si despu\u00e9s de a\u00f1adirlas no se descargan autom\u00e1ticamente, abrir la ventana Gradle (lateral derecho de IntelliJ) y hacer clic en el bot\u00f3n de actualizar.</p>"},{"location":"unidades/ud02/introduccion/#practica-1-proyecto-kotlin-con-gradle","title":"\ud83c\udfaf Pr\u00e1ctica 1: Proyecto Kotlin con Gradle","text":"<p>En esta pr\u00e1ctica has de crear un proyecto que ir\u00e1s ampliando a lo largo de toda la unidad. Realiza lo siguiente:</p> <ul> <li>Piensa en una aplicaci\u00f3n de gesti\u00f3n orientada al sector que prefieras y busca un nombre original (ser\u00e1 el nombre de tu proyecto).</li> <li>Crea un nuevo proyecto con Gradle y comprobar que se ejecuta correctamente (puedes utilizar el c\u00f3digo de ejemplo de IntelliJ).</li> </ul>"}]}